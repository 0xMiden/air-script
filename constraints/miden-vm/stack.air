mod StacktAir

### Helper functions ##############################################################################

fn delta(v: scalar) -> scalar:
    return v' - v


# Flags for the first bits (b[6], b[5], b[4])

fn f_000(b: vector[7]) -> scalar:
    return !b[6] & !b[5] & !b[4]

fn f_001(b: vector[7]) -> scalar:
    return !b[6] & !b[5] & b[4]

fn f_010(b: vector[7]) -> scalar:
    return !b[6] & b[5] & !b[4]

fn f_011(b: vector[7]) -> scalar:
    return !b[6] & b[5] & b[4]

# This flag is equal to f_100
fn f_u32rc(b: vector[7]) -> scalar:
    return b[6] & !b[5] & !b[4]

fn f_101(b: vector[7]) -> scalar:
    return b[6] & !b[5] & b[4]


# Flags for the four last bits (b[3], b[2], b[1], b[0])

fn f_x0000(b: vector[7]) -> scalar:
    return !b[3] & !b[2] & !b[1] & !b[0]

fn f_x0001(b: vector[7]) -> scalar:
    return !b[3] & !b[2] & !b[1] & b[0]

fn f_x0010(b: vector[7]) -> scalar:
    return !b[3] & !b[2] & b[1] & !b[0]

fn f_x0011(b: vector[7]) -> scalar:
    return !b[3] & !b[2] & b[1] & b[0]

fn f_x0100(b: vector[7]) -> scalar:
    return !b[3] & b[2] & !b[1] & !b[0]

fn f_x0101(b: vector[7]) -> scalar:
    return !b[3] & b[2] & !b[1] & b[0]

fn f_x0110(b: vector[7]) -> scalar:
    return !b[3] & b[2] & b[1] & !b[0]

fn f_x0111(b: vector[7]) -> scalar:
    return !b[3] & b[2] & b[1] & b[0]

fn f_x1000(b: vector[7]) -> scalar:
    return b[3] & !b[2] & !b[1] & !b[0]

fn f_x1001(b: vector[7]) -> scalar:
    return b[3] & !b[2] & !b[1] & b[0]

fn f_x1010(b: vector[7]) -> scalar:
    return b[3] & !b[2] & b[1] & !b[0]

fn f_x1011(b: vector[7]) -> scalar:
    return b[3] & !b[2] & b[1] & b[0]

fn f_x1100(b: vector[7]) -> scalar:
    return b[3] & b[2] & !b[1] & !b[0]

fn f_x1101(b: vector[7]) -> scalar:
    return b[3] & b[2] & !b[1] & b[0]

fn f_x1110(b: vector[7]) -> scalar:
    return b[3] & b[2] & b[1] & !b[0]

fn f_x1111(b: vector[7]) -> scalar:
    return b[3] & b[2] & b[1] & b[0]


# No stack shift operations

fn f_noop(b: vector[7]) -> scalar:
    return f_000(b) & f_x0000(b)

fn f_eqz(b: vector[7]) -> scalar:
    return f_000(b) & f_x0001(b)

fn f_neg(b: vector[7]) -> scalar:
    return f_000(b) & f_x0010(b)

fn f_inv(b: vector[7]) -> scalar:
    return f_000(b) & f_x0011(b)

fn f_incr(b: vector[7]) -> scalar:
    return f_000(b) & f_x0100(b)

fn f_not(b: vector[7]) -> scalar:
    return f_000(b) & f_x0101(b)

fn f_fmpadd(b: vector[7]) -> scalar:
    return f_000(b) & f_x0110(b)

fn f_mload(b: vector[7]) -> scalar:
    return f_000(b) & f_x0111(b)

fn f_swap(b: vector[7]) -> scalar:
    return f_000(b) & f_x1000(b)

fn f_caller(b: vector[7]) -> scalar:
    return f_000(b) & f_x1001(b)

fn f_movup2(b: vector[7]) -> scalar:
    return f_000(b) & f_x1010(b)

fn f_movdn2(b: vector[7]) -> scalar:
    return f_000(b) & f_x1011(b)

fn f_movup3(b: vector[7]) -> scalar:
    return f_000(b) & f_x1100(b)

fn f_movdn3(b: vector[7]) -> scalar:
    return f_000(b) & f_x1101(b)

fn f_advpopw(b: vector[7]) -> scalar:
    return f_000(b) & f_x1110(b)

fn f_expacc(b: vector[7]) -> scalar:
    return f_000(b) & f_x1111(b)


fn f_movup4(b: vector[7]) -> scalar:
    return f_001(b) & f_x0000(b)

fn f_movdn4(b: vector[7]) -> scalar:
    return f_001(b) & f_x0001(b)

fn f_movup5(b: vector[7]) -> scalar:
    return f_001(b) & f_x0010(b)

fn f_movdn5(b: vector[7]) -> scalar:
    return f_001(b) & f_x0011(b)

fn f_movup6(b: vector[7]) -> scalar:
    return f_001(b) & f_x0100(b)

fn f_movdn6(b: vector[7]) -> scalar:
    return f_001(b) & f_x0101(b)

fn f_movup7(b: vector[7]) -> scalar:
    return f_001(b) & f_x0110(b)

fn f_movdn7(b: vector[7]) -> scalar:
    return f_001(b) & f_x0111(b)

fn f_swapw(b: vector[7]) -> scalar:
    return f_001(b) & f_x1000(b)

fn f_ext2mul(b: vector[7]) -> scalar:
    return f_001(b) & f_x1001(b)

fn f_movup8(b: vector[7]) -> scalar:
    return f_001(b) & f_x1010(b)

fn f_movdn8(b: vector[7]) -> scalar:
    return f_001(b) & f_x1011(b)

fn f_swapw2(b: vector[7]) -> scalar:
    return f_001(b) & f_x1100(b)

fn f_swapw3(b: vector[7]) -> scalar:
    return f_001(b) & f_x1101(b)

fn f_swapdw(b: vector[7]) -> scalar:
    return f_001(b) & f_x1110(b)


# Left stack shift operations

fn f_assert(b: vector[7]) -> scalar:
    return f_010(b) & f_x0000(b)

fn f_eq(b: vector[7]) -> scalar:
    return f_010(b) & f_x0001(b)

fn f_add(b: vector[7]) -> scalar:
    return f_010(b) & f_x0010(b)

fn f_mul(b: vector[7]) -> scalar:
    return f_010(b) & f_x0011(b)

fn f_and(b: vector[7]) -> scalar:
    return f_010(b) & f_x0100(b)

fn f_or(b: vector[7]) -> scalar:
    return f_010(b) & f_x0101(b)

fn f_u32and(b: vector[7]) -> scalar:
    return f_010(b) & f_x0110(b)

fn f_u32xor(b: vector[7]) -> scalar:
    return f_010(b) & f_x0111(b)

fn f_frie2f4(b: vector[7]) -> scalar:
    return f_010(b) & f_x1000(b)

fn f_drop(b: vector[7]) -> scalar:
    return f_010(b) & f_x1001(b)

fn f_cswap(b: vector[7]) -> scalar:
    return f_010(b) & f_x1010(b)

fn f_cswapw(b: vector[7]) -> scalar:
    return f_010(b) & f_x1011(b)

fn f_mloadw(b: vector[7]) -> scalar:
    return f_010(b) & f_x1100(b)

fn f_mstore(b: vector[7]) -> scalar:
    return f_010(b) & f_x1101(b)

fn f_mstorew(b: vector[7]) -> scalar:
    return f_010(b) & f_x1110(b)

fn f_fmpupdate(b: vector[7]) -> scalar:
    return f_010(b) & f_x1111(b)


# Right stack shift operations

fn f_pad(b: vector[7]) -> scalar:
    return f_011(b) & f_x0000(b)

fn f_dup(b: vector[7]) -> scalar:
    return f_011(b) & f_x0001(b)

fn f_dup1(b: vector[7]) -> scalar:
    return f_011(b) & f_x0010(b)

fn f_dup2(b: vector[7]) -> scalar:
    return f_011(b) & f_x0011(b)

fn f_dup3(b: vector[7]) -> scalar:
    return f_011(b) & f_x0100(b)

fn f_dup4(b: vector[7]) -> scalar:
    return f_011(b) & f_x0101(b)

fn f_dup5(b: vector[7]) -> scalar:
    return f_011(b) & f_x0110(b)

fn f_dup6(b: vector[7]) -> scalar:
    return f_011(b) & f_x0111(b)

fn f_dup7(b: vector[7]) -> scalar:
    return f_011(b) & f_x1000(b)

fn f_dup9(b: vector[7]) -> scalar:
    return f_011(b) & f_x1001(b)

fn f_dup11(b: vector[7]) -> scalar:
    return f_011(b) & f_x1010(b)

fn f_dup13(b: vector[7]) -> scalar:
    return f_011(b) & f_x1011(b)

fn f_dup15(b: vector[7]) -> scalar:
    return f_011(b) & f_x1100(b)

fn f_advpop(b: vector[7]) -> scalar:
    return f_011(b) & f_x1101(b)

fn f_sdepth(b: vector[7]) -> scalar:
    return f_011(b) & f_x1110(b)

fn f_clk(b: vector[7]) -> scalar:
    return f_011(b) & f_x1111(b)


# u32 operations

fn f_u32add(b: vector[7]) -> scalar:
    return f_u32rc(b) & !b[3] & !b[2] & !b[1]

fn f_u32sub(b: vector[7]) -> scalar:
    return f_u32rc(b) & !b[3] & !b[2] & b[1]

fn f_u32mul(b: vector[7]) -> scalar:
    return f_u32rc(b) & !b[3] & b[2] & !b[1]

fn f_u32div(b: vector[7]) -> scalar:
    return f_u32rc(b) & !b[3] & b[2] & b[1]

fn f_u32split(b: vector[7]) -> scalar:
    return f_u32rc(b) & b[3] & !b[2] & !b[1]

fn f_u32assert2(b: vector[7]) -> scalar:
    return f_u32rc(b) & b[3] & !b[2] & b[1]

fn f_u32add3(b: vector[7]) -> scalar:
    return f_u32rc(b) & b[3] & b[2] & !b[1]

fn f_madd(b: vector[7]) -> scalar:
    return f_u32rc(b) & b[3] & b[2] & b[1]


# High-degree operations

fn f_hperm(b: vector[7]) -> scalar:
    return f_101(b) & !b[3] & !b[2] & !b[1]

fn f_mpverify(b: vector[7]) -> scalar:
    return f_101(b) & !b[3] & !b[2] & b[1]

fn f_pipe(b: vector[7]) -> scalar:
    return f_101(b) & !b[3] & b[2] & !b[1]

fn f_mstream(b: vector[7]) -> scalar:
    return f_101(b) & !b[3] & b[2] & b[1]

fn f_span(b: vector[7]) -> scalar:
    return f_101(b) & b[3] & !b[2] & !b[1]

fn f_join(b: vector[7]) -> scalar:
    return f_101(b) & b[3] & !b[2] & b[1]

fn f_split(b: vector[7]) -> scalar:
    return f_101(b) & b[3] & b[2] & !b[1]

fn f_loop(b: vector[7]) -> scalar:
    return f_101(b) & b[3] & b[2] & b[1]


# Very high-degree operations

fn f_mrupdate(b: vector[7], extra: scalar) -> scalar:
    return extra & !b[4] & !b[3] & !b[2]

fn f_push(b: vector[7], extra: scalar) -> scalar:
    return extra & !b[4] & !b[3] & b[2]

fn f_syscall(b: vector[7], extra: scalar) -> scalar:
    return extra & !b[4] & b[3] & !b[2]

fn f_call(b: vector[7], extra: scalar) -> scalar:
    return extra & !b[4] & b[3] & b[2]

fn f_end(b: vector[7], extra: scalar) -> scalar:
    return extra & b[4] & !b[3] & !b[2]

fn f_repeat(b: vector[7], extra: scalar) -> scalar:
    return extra & b[4] & !b[3] & b[2]

fn f_respan(b: vector[7], extra: scalar) -> scalar:
    return extra & b[4] & b[3] & !b[2]

fn f_halt(b: vector[7], extra: scalar) -> scalar:
    return extra & b[4] & b[3] & b[2]


# Composite flags

fn f_shr(b: vector[7], extra: scalar) -> scalar:
    return !b[6] & b[5] & b[4] + f_u32split(b) + f_push(b, extra)

fn f_shl(b: vector[7], extra: scalar, h5: scalar) -> scalar:
    let f_add3_mad = b[6] & !b[5] & !b[4] & b[3] & b[2]
    let f_split_loop = b[6] & !b[5] & b[4] & b[3] & b[2]
    return !b[6] & b[5] & !b[4] + f_add3_mad + f_split_loop + f_repeat(b, extra) + f_end(b, extra) * h5 

fn f_ctrl(b: vector[7], extra: scalar) -> scalar:
    # flag for SPAN, JOIN, SPLIT, LOOP
    let f_sjsl = b[6] & !b[5] & b[4] & b[3]

    # flag for END, REPEAT, RESPAN, HALT
    let f_errh = b[6] & b[5] & b[4]

    return f_sjsl + f_errh + f_call(b, extra) + f_syscall(b, extra)


fn binary_check_sub(elem: scalar) -> scalar:
    return elem^2 - elem


### Helper evaluators #############################################################################

# Enforces that the provided columns must be zero.
ev is_zero(main: [values[4]]):
    enf v = 0 for v in values


# Enforces that values in the columns in the current row must be equal to the values in the next 
# row.
ev is_unchanged(main: [values[4]]):
    enf v' = v for v in values


ev range_check_16bit()


### Stack Air Constraints #########################################################################

# Enforces the constraints on the stack.
# TODO: add docs for columns
# ev stack_constraints(main: [stack[16], bookkeeping[2], helper], aux: [op_bits[7], extra, hasher5]):

# No stack shift operations

ev noop(main: [s[16]], aux: [b[7]]):
    enf f_dup(b) * delta(elem) = 0 for elem in stack

ev eqz(main: [s[16], helper], aux: [b[7]]):
    enf f_eqz(b) * (s[0]' * s[0]) = 0
    enf f_eqz(b) * (s[0]' - (1 - s[0] * helper))
    enf f_eqz(b) * delta(s[i]) = 0 for i in 1..16

ev neg(main: [s[16]], aux: [b[7]]):
    enf f_neg(b) * (s[0]' + s[0]) = 0
    enf f_neg(b) * delta(s[i]) = 0 for i in 1..16

ev inv(main: [s[16]], aux: [b[7]]):
    enf f_inv(b) * (1 - s[0]' * s[0]) = 0
    enf f_inv(b) * delta(s[i]) = 0 for i in 1..16

ev incr(main: [s[16]], aux: [b[7]]):
    enf f_incr(b) * (s[0]' - s[0] - 1) = 0
    enf f_incr(b) * delta(s[i]) = 0 for i in 1..16

ev not(main: [s[16]], aux: [b[7]]):
    enf f_not(b) * binary_check_sub(s[0])
    enf f_not(b) * (s[0]' - !s[0]) = 0
    enf f_not(b) * delta(s[i]) = 0 for i in 1..16

ev fmpadd(main: [s[16]], aux: [b[7], fmp]):
    enf f_fmpadd(b) * (s[0]' - s[0] - fmp) = 0
    enf f_fmpadd(b) * delta(s[i]) = 0 for i in 1..16

# WARNING: not sure that I got the constraint right
# What are the "helper" columns? Is it just a different name for hasher decoder columns, or they 
# are unique for i/o ops?
ev mload(main: [s[16]], aux: [b[7], helper[3], clk, b_chip]):
    let v = alpha[5] * s[0]' + sum([alpha[i + 5] * helper[3 - i]'])
    let op_mem_read = 12
    let u_mem = alpha[0] + alpha[1] * op_mem_read + alpha[3] * s[0] + alpha[4] * clk + v
    enf f_mload(b) * (b_chip' * u_mem - b_chip) = 0
    enf f_mload(b) * delta(s[i]) = 0 for i in 1..16

ev swap(main: [s[16]], aux: [b[7]]):
    enf f_swap(b) * (s[0]' - s[1]) = 0
    enf f_swap(b) * (s[1]' - s[0]) = 0
    enf f_swap(b) * delta(s[i]) = 0 for i in 2..16

# TODO: add constraints
ev caller(main: [s[16]], aux: [b[7]]):

ev movup2(main: [s[16]], aux: [b[7]]):
    enf f_movup2(b) * (s[0]' - s[2]) = 0
    enf f_movup2(b) * (s[i + 1]' - s[i]) = 0 for i in 0..2
    enf f_movup2(b) * delta(s[i]) = 0 for i in 3..16

ev movdn2(main: [s[16]], aux: [b[7]]):
    enf f_movdn2(b) * (s[2]' - s[0]) = 0
    enf f_movdn2(b) * (s[i]' - s[i + 1]) = 0 for i in 0..2
    enf f_movdn2(b) * delta(s[i]) = 0 for i in 3..16

ev movup3(main: [s[16]], aux: [b[7]]):
    enf f_movup3(b) * (s[0]' - s[3]) = 0
    enf f_movup3(b) * (s[i + 1]' - s[i]) = 0 for i in 0..3
    enf f_movup3(b) * delta(s[i]) = 0 for i in 4..16

ev movdn3(main: [s[16]], aux: [b[7]]):
    enf f_movdn3(b) * (s[3]' - s[0]) = 0
    enf f_movdn3(b) * (s[i]' - s[i + 1]) = 0 for i in 0..3
    enf f_movdn3(b) * delta(s[i]) = 0 for i in 4..16

ev advpopw(main: [s[16]], aux: [b[7]]):
    enf f_advpopw(b) * delta(s[i]) = 0 for i in 4..16

ev expacc(main: [s[16]], aux: [b[7], helper]):
    enf f_expacc(b) * binary_check_sub(s[0]')
    enf f_expacc(b) * (s[1]' - s[1]^2) = 0
    enf f_expacc(b) * (helper - ((s[1] - 1) * s[0]' + 1)) = 0
    enf f_expacc(b) * (s[2]' - s[2] * helper) = 0
    enf f_expacc(b) * (s[3]' - (s[3] * 2 + s[0]')) = 0
    enf f_expacc(b) * delta(s[i]) = 0 for i in 4..16

ev movup4(main: [s[16]], aux: [b[7]]):
    enf f_movup4(b) * (s[0]' - s[4]) = 0
    enf f_movup4(b) * (s[i + 1]' - s[i]) = 0 for i in 0..4
    enf f_movup4(b) * delta(s[i]) = 0 for i in 5..16

ev movdn4(main: [s[16]], aux: [b[7]]):
    enf f_movdn4(b) * (s[4]' - s[0]) = 0
    enf f_movdn4(b) * (s[i]' - s[i + 1]) = 0 for i in 0..4
    enf f_movdn4(b) * delta(s[i]) = 0 for i in 5..16

ev movup5(main: [s[16]], aux: [b[7]]):
    enf f_movup5(b) * (s[0]' - s[5]) = 0
    enf f_movup5(b) * (s[i + 1]' - s[i]) = 0 for i in 0..5
    enf f_movup5(b) * delta(s[i]) = 0 for i in 6..16

ev movdn5(main: [s[16]], aux: [b[7]]):
    enf f_movdn5(b) * (s[5]' - s[0]) = 0
    enf f_movdn5(b) * (s[i]' - s[i + 1]) = 0 for i in 0..5
    enf f_movdn5(b) * delta(s[i]) = 0 for i in 6..16

ev movup6(main: [s[16]], aux: [b[7]]):
    enf f_movup6(b) * (s[0]' - s[6]) = 0
    enf f_movup6(b) * (s[i + 1]' - s[i]) = 0 for i in 0..6
    enf f_movup6(b) * delta(s[i]) = 0 for i in 7..16

ev movdn6(main: [s[16]], aux: [b[7]]):
    enf f_movdn6(b) * (s[6]' - s[0]) = 0
    enf f_movdn6(b) * (s[i]' - s[i + 1]) = 0 for i in 0..6
    enf f_movdn6(b) * delta(s[i]) = 0 for i in 7..16

ev movup7(main: [s[16]], aux: [b[7]]):
    enf f_movup7(b) * (s[0]' - s[7]) = 0
    enf f_movup7(b) * (s[i + 1]' - s[i]) = 0 for i in 0..7
    enf f_movup7(b) * delta(s[i]) = 0 for i in 8..16

ev movdn7(main: [s[16]], aux: [b[7]]):
    enf f_movdn7(b) * (s[7]' - s[0]) = 0
    enf f_movdn7(b) * (s[i]' - s[i + 1]) = 0 for i in 0..7
    enf f_movdn7(b) * delta(s[i]) = 0 for i in 8..16

ev swapw(main: [s[16]], aux: [b[7]]):
    enf f_swapw(b) * (s[i]' - s[i + 4]) = 0 for i in 0..4
    enf f_swapw(b) * (s[i + 4]' - s[i]) = 0 for i in 0..4
    enf f_swapw(b) * delta(s[i]) = 0 for i in 8..16

ev ext2mul(main: [s[16]], aux: [b[7]]):
    enf f_ext2mul(b) * (s[0]' - s[0]) = 0
    enf f_ext2mul(b) * (s[1]' - s[1]) = 0
    enf f_ext2mul(b) * (s[2]' - (s[0] + s[1]) * (s[2] + s[3]) + s[0] * s[2]) = 0
    enf f_ext2mul(b) * (s[3]' - s[1] * s[3] + 2 * s[0] * s[2]) = 0
    enf f_ext2mul(b) * delta(s[i]) = 0 for i in 4..16

ev movup8(main: [s[16]], aux: [b[7]]):
    enf f_movup8(b) * (s[0]' - s[8]) = 0
    enf f_movup8(b) * (s[i + 1]' - s[i]) = 0 for i in 0..8
    enf f_movup8(b) * delta(s[i]) = 0 for i in 9..16

ev movdn8(main: [s[16]], aux: [b[7]]):
    enf f_movdn8(b) * (s[8]' - s[0]) = 0
    enf f_movdn8(b) * (s[i]' - s[i + 1]) = 0 for i in 0..8
    enf f_movdn8(b) * delta(s[i]) = 0 for i in 9..16

ev swapw2(main: [s[16]], aux: [b[7]]):
    enf f_swapw2(b) * (s[i]' - s[i + 8]) = 0 for i in 0..4
    enf f_swapw2(b) * (s[i + 8]' - s[i]) = 0 for i in 0..4
    enf f_swapw2(b) * delta(s[i]) = 0 for i in 4..8
    enf f_swapw2(b) * delta(s[i]) = 0 for i in 12..16

# Should we enforce that elements in position grater than 15 do not change? 
ev swapw3(main: [s[16]], aux: [b[7]]):
    enf f_swapw3(b) * (s[i]' - s[i + 12]) = 0 for i in 0..4
    enf f_swapw3(b) * (s[i + 12]' - s[i]) = 0 for i in 0..4
    enf f_swapw3(b) * delta(s[i]) = 0 for i in 4..12

# Should we enforce that elements in position grater than 15 do not change? 
ev swapdw(main: [s[16]], aux: [b[7]]):
    enf f_swapdw(b) * (s[i]' - s[i + 8]) = 0 for i in 0..8
    enf f_swapdw(b) * (s[i + 8]' - s[i]) = 0 for i in 0..8


# Left stack shift operationds

ev assert(main: [s[16]], aux: [b[7]]):
    enf f_assert(b) * (s[0] - 1) = 0
    enf f_assert(b) * (s[i]' - s[i + 1]) = 0 for i in 0..15

ev eq(main: [s[16]], aux: [b[7], helper]):
    enf f_eq(b) * (s[0]' * (s[0] - s[1])) = 0
    enf f_eq(b) * (s[0]' - (1 - (s[0] - s[1]) * helper)) = 0
    enf f_eq(b) * (s[i]' - s[i + 1]) = 0 for i in 1..15

ev add(main: [s[16]], aux: [b[7]]):
    enf f_add(b) * (s[0]' - (s[0] + s[1])) = 0
    enf f_eq(b) * (s[i]' - s[i + 1]) = 0 for i in 1..15

ev mul(main: [s[16]], aux: [b[7]]):
    enf f_mul(b) * (s[0]' - s[0] * s[1]) = 0
    enf f_mul(b) * (s[i]' - s[i + 1]) = 0 for i in 1..15

ev and(main: [s[16]], aux: [b[7]]):
    enf f_and(b) * binary_check_sub(s[i]) = 0 for i in 0..2
    enf f_and(b) * (s[0]' - s[0] * s[1]) = 0
    enf f_and(b) * (s[i]' - s[i + 1]) = 0 for i in 1..15

ev or(main: [s[16]], aux: [b[7]]):
    enf f_or(b) * binary_check_sub(s[i]) = 0 for i in 0..2
    enf f_or(b) * (s[0]' - (s[1] + s[0] - s[1] * s[0])) = 0
    enf f_or(b) * (s[i]' - s[i + 1]) = 0 for i in 1..15

ev u32and(main: [s[16]], aux: [b[7], b_chip]):
    let op_u32and = 2
    enf f_u32and(b) * b_chip' * (alpha[0] + alpha[1] * op_u32and + alpha[2] * s[0] + alpha[3] * s[1] + alpha[4] * s[0]') = b_chip
    enf f_u32and(b) * (s[i]' - s[i + 1]) = 0 for i in 1..15

ev u32xor(main: [s[16]], aux: [b[7], b_chip]):
    let op_u32xor = 6
    enf f_u32xor(b) * b_chip' * (alpha[0] + alpha[1] * op_u32xor + alpha[2] * s[0] + alpha[3] * s[1] + alpha[4] * s[0]') = b_chip
    enf f_u32xor(b) * (s[i]' - s[i + 1]) = 0 for i in 1..15

# TODO: add constraints
ev frie2f4(main: [s[16]], aux: [b[7]]):


ev drop(main: [s[16]], aux: [b[7]]):
    enf f_drop(b) * (s[i]' - s[i + 1]) = 0 for i in 0..15

ev cswap(main: [s[16]], aux: [b[7]]):
    enf f_cswap(b) * binary_check_sub(s[0]) = 0
    enf f_cswap(b) * (s[0]' - s[0] * s[2] - (1 - s[0]) * s[1]) = 0
    enf f_cswap(b) * (s[1]' - s[0] * s[1] - (1 - s[0]) * s[2]) = 0
    enf f_cswap(b) * (s[i]' - s[i + 1]) = 0 for i in 2..15

ev cswapw(main: [s[16]], aux: [b[7]]):
    enf f_cswapw(b) * binary_check_sub(s[0]) = 0
    enf f_cswapw(b) * (s[i]' - s[0] * s[i + 5] - (1 - s[0]) * s[i + 1]) = 0 for i in 0..4
    enf f_cswapw(b) * (s[i + 4]' - s[0] * s[i + 1] + (1 - s[0]) * s[i + 5]) = 0 for i in 0..4
    enf f_cswapw(b) * (s[i]' - s[i + 1]) = 0 for i in 8..15

ev mloadw(main: [s[16]], aux: [b[7], b_chip, clk]):
    let v = sum([alpha[i + 5] * s[3 - i]' for i in 0..4])
    let op_mem_read = 12
    let u_mem = alpha[0] + alpha[1] * op_mem_read + alpha[3] * s[0] + alpha[4] * clk + v
    enf f_mloadw(b) * (b_chip' * u_mem - b_chip) = 0
    enf f_mloadw(b) * (s[i]' - s[i + 1]) = 0 for i in 4..15

ev mstore(main: [s[16]], aux: [b[7], helper[3], clk, b_chip]):
    let v = alpha[5] * s[0]' + sum([alpha[i + 5] * helper[3 - i]' for i in 1..4])
    let op_mem_write = 4
    let u_mem = alpha[0] + alpha[1] * op_mem_write + alpha[3] * s[0] + alpha[4] * clk + v
    enf f_mstore(b) * (b_chip' * u_mem - b_chip) = 0
    enf f_mstore(b) * (s[i]' - s[i + 1]) = 0 for i in 0..15

ev mstorew(main: [s[16]], aux: [b[7]]):
    let v = sum([alpha[i + 5] * s[3 - i]']) for i in 0..4
    let op_mem_write = 4
    let u_mem = alpha[0] + alpha[1] * op_mem_write + alpha[3] * s[0] + alpha[4] * clk + v
    enf f_mstorew(b) * (b_chip' * u_mem - b_chip) = 0
    enf f_mstore(b) * (s[i]' - s[i + 1]) = 0 for i in 0..15

ev fmpupdate(main: [s[16]], aux: [b[7], fmp]):
    enf f_fmpupdate(b) * (fmp' - (fmp + s[0])) = 0
    enf f_fmpupdate(b) * (s[i]' - s[i + 1]) = 0 for i in 0..15


# Right stack shift operations

ev pad(main: [s[16]], aux: [b[7]]):
    enf f_pad(b) * s[0]' = 0
    enf f_pad(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup(main: [s[16]], aux: [b[7]]):
    enf f_dup(b) * (s[0]' - s[0]) = 0
    enf f_dup(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup1(main: [s[16]], aux: [b[7]]):
    enf f_dup1(b) * (s[0]' - s[1]) = 0
    enf f_dup1(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup2(main: [s[16]], aux: [b[7]]):
    enf f_dup2(b) * (s[0]' - s[2]) = 0
    enf f_dup2(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup3(main: [s[16]], aux: [b[7]]):
    enf f_dup3(b) * (s[0]' - s[3]) = 0
    enf f_dup3(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup4(main: [s[16]], aux: [b[7]]):
    enf f_dup4(b) * (s[0]' - s[4]) = 0
    enf f_dup4(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup5(main: [s[16]], aux: [b[7]]):
    enf f_dup5(b) * (s[0]' - s[5]) = 0
    enf f_dup5(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup6(main: [s[16]], aux: [b[7]]):
    enf f_dup6(b) * (s[0]' - s[6]) = 0
    enf f_dup6(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup7(main: [s[16]], aux: [b[7]]):
    enf f_dup7(b) * (s[0]' - s[7]) = 0
    enf f_dup7(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup9(main: [s[16]], aux: [b[7]]):
    enf f_dup9(b) * (s[0]' - s[9]) = 0
    enf f_dup9(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup11(main: [s[16]], aux: [b[7]]):
    enf f_dup11(b) * (s[0]' - s[11]) = 0
    enf f_dup11(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup13(main: [s[16]], aux: [b[7]]):
    enf f_dup13(b) * (s[0]' - s[13]) = 0
    enf f_dup13(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev dup15(main: [s[16]], aux: [b[7]]):
    enf f_dup15(b) * (s[0]' - s[15]) = 0
    enf f_dup15(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev advpop(main: [s[16]], aux: [b[7]]):
    enf f_advpop(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev sdepth(main: [s[16], bookkeeping[2]], aux: [b[7]]):
    enf f_sdepth(b) * (s[0]' - b[0]) = 0
    enf f_sdepth(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15

ev clk(main: [s[16]], aux: [b[7], clk]):
    enf f_clk(b) * (s[0]' - clk) = 0
    enf f_clk(b) * (s[i + 1]' - s[i]) = 0 for i in 0..15
