mod StacktAir

### Helper functions ##############################################################################

fn delta(v: scalar) -> scalar:
    return v' - v


# Flags for the first bits (b[6], b[5], b[4])

fn f_000(b: vector[7]) -> scalar:
    return !b[6] & !b[5] & !b[4]

fn f_001(b: vector[7]) -> scalar:
    return !b[6] & !b[5] & b[4]

fn f_010(b: vector[7]) -> scalar:
    return !b[6] & b[5] & !b[4]

fn f_011(b: vector[7]) -> scalar:
    return !b[6] & b[5] & b[4]

# This flag is equal to f_100
fn f_u32rc(b: vector[7]) -> scalar:
    return b[6] & !b[5] & !b[4]

fn f_101(b: vector[7]) -> scalar:
    return b[6] & !b[5] & b[4]


# Flags for the four last bits (b[3], b[2], b[1], b[0])

fn f_x0000(b: vector[7]) -> scalar:
    return !b[3] & !b[2] & !b[1] & !b[0]

fn f_x0001(b: vector[7]) -> scalar:
    return !b[3] & !b[2] & !b[1] & b[0]

fn f_x0010(b: vector[7]) -> scalar:
    return !b[3] & !b[2] & b[1] & !b[0]

fn f_x0011(b: vector[7]) -> scalar:
    return !b[3] & !b[2] & b[1] & b[0]

fn f_x0100(b: vector[7]) -> scalar:
    return !b[3] & b[2] & !b[1] & !b[0]

fn f_x0101(b: vector[7]) -> scalar:
    return !b[3] & b[2] & !b[1] & b[0]

fn f_x0110(b: vector[7]) -> scalar:
    return !b[3] & b[2] & b[1] & !b[0]

fn f_x0111(b: vector[7]) -> scalar:
    return !b[3] & b[2] & b[1] & b[0]

fn f_x1000(b: vector[7]) -> scalar:
    return b[3] & !b[2] & !b[1] & !b[0]

fn f_x1001(b: vector[7]) -> scalar:
    return b[3] & !b[2] & !b[1] & b[0]

fn f_x1010(b: vector[7]) -> scalar:
    return b[3] & !b[2] & b[1] & !b[0]

fn f_x1011(b: vector[7]) -> scalar:
    return b[3] & !b[2] & b[1] & b[0]

fn f_x1100(b: vector[7]) -> scalar:
    return b[3] & b[2] & !b[1] & !b[0]

fn f_x1101(b: vector[7]) -> scalar:
    return b[3] & b[2] & !b[1] & b[0]

fn f_x1110(b: vector[7]) -> scalar:
    return b[3] & b[2] & b[1] & !b[0]

fn f_x1111(b: vector[7]) -> scalar:
    return b[3] & b[2] & b[1] & b[0]


# No stack shift operations

fn f_noop(b: vector[7]) -> scalar:
    return f_000(b) & f_x0000(b)

fn f_eqz(b: vector[7]) -> scalar:
    return f_000(b) & f_x0001(b)

fn f_neg(b: vector[7]) -> scalar:
    return f_000(b) & f_x0010(b)

fn f_inv(b: vector[7]) -> scalar:
    return f_000(b) & f_x0011(b)

fn f_incr(b: vector[7]) -> scalar:
    return f_000(b) & f_x0100(b)

fn f_not(b: vector[7]) -> scalar:
    return f_000(b) & f_x0101(b)

fn f_fmpadd(b: vector[7]) -> scalar:
    return f_000(b) & f_x0110(b)

fn f_mload(b: vector[7]) -> scalar:
    return f_000(b) & f_x0111(b)

fn f_swap(b: vector[7]) -> scalar:
    return f_000(b) & f_x1000(b)

fn f_caller(b: vector[7]) -> scalar:
    return f_000(b) & f_x1001(b)

fn f_movup2(b: vector[7]) -> scalar:
    return f_000(b) & f_x1010(b)

fn f_movdn2(b: vector[7]) -> scalar:
    return f_000(b) & f_x1011(b)

fn f_movup3(b: vector[7]) -> scalar:
    return f_000(b) & f_x1100(b)

fn f_movdn3(b: vector[7]) -> scalar:
    return f_000(b) & f_x1101(b)

fn f_advpopw(b: vector[7]) -> scalar:
    return f_000(b) & f_x1110(b)

fn f_expacc(b: vector[7]) -> scalar:
    return f_000(b) & f_x1111(b)


fn f_movup4(b: vector[7]) -> scalar:
    return f_001(b) & f_x0000(b)

fn f_movdn4(b: vector[7]) -> scalar:
    return f_001(b) & f_x0001(b)

fn f_movup5(b: vector[7]) -> scalar:
    return f_001(b) & f_x0010(b)

fn f_movdn5(b: vector[7]) -> scalar:
    return f_001(b) & f_x0011(b)

fn f_movup6(b: vector[7]) -> scalar:
    return f_001(b) & f_x0100(b)

fn f_movdn6(b: vector[7]) -> scalar:
    return f_001(b) & f_x0101(b)

fn f_movup7(b: vector[7]) -> scalar:
    return f_001(b) & f_x0110(b)

fn f_movdn7(b: vector[7]) -> scalar:
    return f_001(b) & f_x0111(b)

fn f_swapw(b: vector[7]) -> scalar:
    return f_001(b) & f_x1000(b)

fn f_ext2mul(b: vector[7]) -> scalar:
    return f_001(b) & f_x1001(b)

fn f_movup8(b: vector[7]) -> scalar:
    return f_001(b) & f_x1010(b)

fn f_movdn8(b: vector[7]) -> scalar:
    return f_001(b) & f_x1011(b)

fn f_swapw2(b: vector[7]) -> scalar:
    return f_001(b) & f_x1100(b)

fn f_swapw3(b: vector[7]) -> scalar:
    return f_001(b) & f_x1101(b)

fn f_swapdw(b: vector[7]) -> scalar:
    return f_001(b) & f_x1110(b)

fn f_001_1111() -> scalar:
    return 0


# Left stack shift operations

fn f_assert(b: vector[7]) -> scalar:
    return f_010(b) & f_x0000(b)

fn f_eq(b: vector[7]) -> scalar:
    return f_010(b) & f_x0001(b)

fn f_add(b: vector[7]) -> scalar:
    return f_010(b) & f_x0010(b)

fn f_mul(b: vector[7]) -> scalar:
    return f_010(b) & f_x0011(b)

fn f_and(b: vector[7]) -> scalar:
    return f_010(b) & f_x0100(b)

fn f_or(b: vector[7]) -> scalar:
    return f_010(b) & f_x0101(b)

fn f_u32and(b: vector[7]) -> scalar:
    return f_010(b) & f_x0110(b)

fn f_u32xor(b: vector[7]) -> scalar:
    return f_010(b) & f_x0111(b)

fn f_frie2f4(b: vector[7]) -> scalar:
    return f_010(b) & f_x1000(b)

fn f_drop(b: vector[7]) -> scalar:
    return f_010(b) & f_x1001(b)

fn f_cswap(b: vector[7]) -> scalar:
    return f_010(b) & f_x1010(b)

fn f_cswapw(b: vector[7]) -> scalar:
    return f_010(b) & f_x1011(b)

fn f_mloadw(b: vector[7]) -> scalar:
    return f_010(b) & f_x1100(b)

fn f_mstore(b: vector[7]) -> scalar:
    return f_010(b) & f_x1101(b)

fn f_mstorew(b: vector[7]) -> scalar:
    return f_010(b) & f_x1110(b)

fn f_fmpupdate(b: vector[7]) -> scalar:
    return f_010(b) & f_x1111(b)


# Right stack shift operations

fn f_pad(b: vector[7]) -> scalar:
    return f_011(b) & f_x0000(b)

fn f_dup(b: vector[7]) -> scalar:
    return f_011(b) & f_x0001(b)

fn f_dup1(b: vector[7]) -> scalar:
    return f_011(b) & f_x0010(b)

fn f_dup2(b: vector[7]) -> scalar:
    return f_011(b) & f_x0011(b)

fn f_dup3(b: vector[7]) -> scalar:
    return f_011(b) & f_x0100(b)

fn f_dup4(b: vector[7]) -> scalar:
    return f_011(b) & f_x0101(b)

fn f_dup5(b: vector[7]) -> scalar:
    return f_011(b) & f_x0110(b)

fn f_dup6(b: vector[7]) -> scalar:
    return f_011(b) & f_x0111(b)

fn f_dup7(b: vector[7]) -> scalar:
    return f_011(b) & f_x1000(b)

fn f_dup9(b: vector[7]) -> scalar:
    return f_011(b) & f_x1001(b)

fn f_dup11(b: vector[7]) -> scalar:
    return f_011(b) & f_x1010(b)

fn f_dup13(b: vector[7]) -> scalar:
    return f_011(b) & f_x1011(b)

fn f_dup15(b: vector[7]) -> scalar:
    return f_011(b) & f_x1100(b)

fn f_advpop(b: vector[7]) -> scalar:
    return f_011(b) & f_x1101(b)

fn f_sdepth(b: vector[7]) -> scalar:
    return f_011(b) & f_x1110(b)

fn f_clk(b: vector[7]) -> scalar:
    return f_011(b) & f_x1111(b)


# u32 operations

fn f_u32add(b: vector[7]) -> scalar:
    return f_u32rc(b) & !b[3] & !b[2] & !b[1]

fn f_u32sub(b: vector[7]) -> scalar:
    return f_u32rc(b) & !b[3] & !b[2] & b[1]

fn f_u32mul(b: vector[7]) -> scalar:
    return f_u32rc(b) & !b[3] & b[2] & !b[1]

fn f_u32div(b: vector[7]) -> scalar:
    return f_u32rc(b) & !b[3] & b[2] & b[1]

fn f_u32split(b: vector[7]) -> scalar:
    return f_u32rc(b) & b[3] & !b[2] & !b[1]

fn f_u32assert2(b: vector[7]) -> scalar:
    return f_u32rc(b) & b[3] & !b[2] & b[1]

fn f_u32add3(b: vector[7]) -> scalar:
    return f_u32rc(b) & b[3] & b[2] & !b[1]

fn f_madd(b: vector[7]) -> scalar:
    return f_u32rc(b) & b[3] & b[2] & b[1]


# High-degree operations

fn f_hperm(b: vector[7]) -> scalar:
    return f_101(b) & !b[3] & !b[2] & !b[1]

fn f_mpverify(b: vector[7]) -> scalar:
    return f_101(b) & !b[3] & !b[2] & b[1]

fn f_pipe(b: vector[7]) -> scalar:
    return f_101(b) & !b[3] & b[2] & !b[1]

fn f_mstream(b: vector[7]) -> scalar:
    return f_101(b) & !b[3] & b[2] & b[1]

fn f_span(b: vector[7]) -> scalar:
    return f_101(b) & b[3] & !b[2] & !b[1]

fn f_join(b: vector[7]) -> scalar:
    return f_101(b) & b[3] & !b[2] & b[1]

fn f_split(b: vector[7]) -> scalar:
    return f_101(b) & b[3] & b[2] & !b[1]

fn f_loop(b: vector[7]) -> scalar:
    return f_101(b) & b[3] & b[2] & b[1]


# Very high-degree operations

fn f_mrupdate(b: vector[7], extra: scalar) -> scalar:
    return extra & !b[4] & !b[3] & !b[2]

fn f_push(b: vector[7], extra: scalar) -> scalar:
    return extra & !b[4] & !b[3] & b[2]

fn f_syscall(b: vector[7], extra: scalar) -> scalar:
    return extra & !b[4] & b[3] & !b[2]

fn f_call(b: vector[7], extra: scalar) -> scalar:
    return extra & !b[4] & b[3] & b[2]

fn f_end(b: vector[7], extra: scalar) -> scalar:
    return extra & b[4] & !b[3] & !b[2]

fn f_repeat(b: vector[7], extra: scalar) -> scalar:
    return extra & b[4] & !b[3] & b[2]

fn f_respan(b: vector[7], extra: scalar) -> scalar:
    return extra & b[4] & b[3] & !b[2]

fn f_halt(b: vector[7], extra: scalar) -> scalar:
    return extra & b[4] & b[3] & b[2]


# Composite flags

fn f_shr(b: vector[7], extra: scalar) -> scalar:
    return !b[6] & b[5] & b[4] + f_u32split(b) + f_push(b, extra)

fn f_shl(b: vector[7], extra: scalar, h5: scalar) -> scalar:
    let f_add3_mad = b[6] & !b[5] & !b[4] & b[3] & b[2]
    let f_split_loop = b[6] & !b[5] & b[4] & b[3] & b[2]
    return !b[6] & b[5] & !b[4] + f_add3_mad + f_split_loop + f_repeat(b, extra) + f_end(b, extra) * h5 

fn f_ctrl(b: vector[7], extra: scalar) -> scalar:
    # flag for SPAN, JOIN, SPLIT, LOOP
    let f_sjsl = b[6] & !b[5] & b[4] & b[3]

    # flag for END, REPEAT, RESPAN, HALT
    let f_errh = b[6] & b[5] & b[4]

    return f_sjsl + f_errh + f_call(b, extra) + f_syscall(b, extra)


fn compute_op_flags(b: vector[7], extra: scalar) -> vector[88]:
    return [
        f_noop(b),
        f_eqz(b),
        f_neg(b),
        f_inv(b),
        f_incr(b),
        f_not(b),
        f_fmpadd(b),
        f_mload(b),
        f_swap(b),
        f_caller(b),
        f_movup2(b),
        f_movdn2(b),
        f_movup3(b),
        f_movdn3(b),
        f_advpopw(b),
        f_expacc(b),
        f_movup4(b),
        f_movdn4(b),
        f_movup5(b),
        f_movdn5(b),
        f_movup6(b),
        f_movdn6(b),
        f_movup7(b),
        f_movdn7(b),
        f_swapw(b),
        f_ext2mul(b),
        f_movup8(b),
        f_movdn8(b),
        f_swapw2(b),
        f_swapw3(b),
        f_swapdw(b),
        f_001_1111(b),

        f_assert(b),
        f_eq(b),
        f_add(b),
        f_mul(b),
        f_and(b),
        f_or(b),
        f_u32and(b),
        f_u32xor(b),
        f_frie2f4(b),
        f_drop(b),
        f_cswap(b),
        f_cswapw(b),
        f_mloadw(b),
        f_mstore(b),
        f_mstorew(b),
        f_fmpupdate(b),

        f_pad(b),
        f_dup(b),
        f_dup1(b),
        f_dup2(b),
        f_dup3(b),
        f_dup4(b),
        f_dup5(b),
        f_dup6(b),
        f_dup7(b),
        f_dup9(b),
        f_dup11(b),
        f_dup13(b),
        f_dup15(b),
        f_advpop(b),
        f_sdepth(b),
        f_clk(b),

        f_u32add(b),
        f_u32sub(b),
        f_u32mul(b),
        f_u32div(b),
        f_u32split(b),
        f_u32assert2(b),
        f_u32add3(b),
        f_madd(b),

        f_hperm(b),
        f_mpverify(b),
        f_pipe(b),
        f_mstream(b),
        f_span(b),
        f_join(b),
        f_split(b),
        f_loop(b),

        f_mrupdate(b, extra),
        f_push(b, extra),
        f_syscall(b, extra),
        f_call(b, extra),
        f_end(b, extra),
        f_repeat(b, extra),
        f_respan(b, extra),
        f_halt(b, extra)
    ]


### Helper evaluators #############################################################################

# Enforces that the provided columns must be zero.
ev is_zero(main: [values[4]]):
    enf v = 0 for v in values


# Enforces that values in the columns in the current row must be equal to the values in the next 
# row.
ev is_unchanged(main: [values[4]]):
    enf v' = v for v in values


# Enforces that the provided columns must be binary.
ev is_binary(main: [a]):
    enf a^2 = a


ev range_check_16bit()


### Stack Air Constraints #########################################################################

# Enforces the constraints on the stack.
# TODO: add docs for columns
ev stack_constraints(main: [stack[16], bookkeeping[2], h0], aux: [op_bits[7], extra, hasher5, fmp, helper[3], clk, b_chip]):
    let op_flags = compute_op_flags(op_bits, extra)
    match enf:
        noop([stack]) when op_flags[0]
        eqz([stack, h0]) when op_flags[1]
        neg([stack]) when op_flags[2]
        inv([stack]) when op_flags[3]
        incr([stack]) when op_flags[4]
        not([stack]) when op_flags[5]
        fmpadd([stack], [fmp]) when op_flags[6]
        mload([stack], [helper, clk, b_chip]) when op_flags[7]
        swap([stack]) when op_flags[8]
        # TODO: add match variant for caller 
        caller()
        movup2([stack]) when op_flags[10]
        movdn2([stack]) when op_flags[11]
        movup3([stack]) when op_flags[12]
        movdn3([stack]) when op_flags[13]
        advpopw([stack]) when op_flags[14]
        expacc([stack], [h0]) when op_flags[15]
        movup4([stack]) when op_flags[16]
        movdn4([stack]) when op_flags[17]
        movup5([stack]) when op_flags[18]
        movdn5([stack]) when op_flags[19]
        movup6([stack]) when op_flags[20]
        movdn6([stack]) when op_flags[21]
        movup7([stack]) when op_flags[22]
        movdn7([stack]) when op_flags[23]
        swapw([stack]) when op_flags[24]
        ext2mul([stack]) when op_flags[25]
        movup8([stack]) when op_flags[26]
        movdn8([stack]) when op_flags[27]
        swapw2([stack]) when op_flags[28]
        swapw3([stack]) when op_flags[29]
        swapdw([stack]) when op_flags[30]

        assert([stack]) when op_flags[32]
        eq([stack], [h0]) when op_flags[33]
        add([stack]) when op_flags[34]
        mul([stack]) when op_flags[35]
        and([stack]) when op_flags[36]
        or([stack]) when op_flags[37]
        u32and([stack], [b_chip]) when op_flags[38]
        u32xor([stack], [b_chip]) when op_flags[39]
        # TODO: add match variant for caller 
        frie2f4()
        drop([stack]) when op_flags[41]
        cswap([stack]) when op_flags[42]
        cswapw([stack]) when op_flags[43]
        mloadw([stack], [clk, b_chip]) when op_flags[44]
        mstore([stack], [helper[3], clk, b_chip]) when op_flags[45]
        mstorew([stack], [clk, b_chip]) when op_flags[46]
        fmpupdate([stack], [fmp]) when op_flags[47]

        pad([stack]) when op_flags[48]
        dup([stack]) when op_flags[49]
        dup1([stack]) when op_flags[50]
        dup2([stack]) when op_flags[51]
        dup3([stack]) when op_flags[52]
        dup4([stack]) when op_flags[53]
        dup5([stack]) when op_flags[54]
        dup6([stack]) when op_flags[55]
        dup7([stack]) when op_flags[56]
        dup9([stack]) when op_flags[57]
        dup11([stack]) when op_flags[58]
        dup13([stack]) when op_flags[59]
        dup15([stack]) when op_flags[60]
        advpop([stack]) when op_flags[61]
        sdepth([stack, bookkeeping]) when op_flags[62]
        clk([stack], [clk]) when op_flags[63]



# No stack shift operations

ev noop(main: [s[16]]):
    enf delta(elem) = 0 for elem in s

ev eqz(main: [s[16], h0]):
    enf s[0]' * s[0] = 0
    enf s[0]' = 1 - s[0] * h0
    enf delta(s[i]) = 0 for i in 1..16

ev neg(main: [s[16]]):
    enf s[0]' + s[0] = 0
    enf delta(s[i]) = 0 for i in 1..16

ev inv(main: [s[16]]):
    enf s[0]' * s[0] = 1
    enf delta(s[i]) = 0 for i in 1..16

ev incr(main: [s[16]]):
    enf s[0]' = s[0] + 1
    enf delta(s[i]) = 0 for i in 1..16

ev not(main: [s[16]]):
    enf is_binary([s[0]])
    enf s[0]' = !s[0]
    enf delta(s[i]) = 0 for i in 1..16

ev fmpadd(main: [s[16]], aux: [fmp]):
    enf s[0]' = s[0] + fmp
    enf delta(s[i]) = 0 for i in 1..16

# WARNING: not sure that I got the constraint right
# What are the "helper" columns? Is it just a different name for hasher decoder columns, or they 
# are unique for i/o ops?
ev mload(main: [s[16]], aux: [helper[3], clk, b_chip]):
    let v = alpha[5] * s[0]' + sum([alpha[i + 5] * helper[3 - i]'])
    let op_mem_read = 12
    let u_mem = alpha[0] + alpha[1] * op_mem_read + alpha[3] * s[0] + alpha[4] * clk + v
    enf b_chip' * u_mem = b_chip
    enf delta(s[i]) = 0 for i in 1..16

ev swap(main: [s[16]]):
    enf s[0]' = s[1]
    enf s[1]' = s[0]
    enf delta(s[i]) = 0 for i in 2..16

# TODO: add constraints
ev caller(main: [s[16]]):

ev movup2(main: [s[16]]):
    enf s[0]' = s[2]
    enf s[i + 1]' = s[i] for i in 0..2
    enf delta(s[i]) = 0 for i in 3..16

ev movdn2(main: [s[16]]):
    enf s[2]' = s[0]
    enf s[i]' = s[i + 1] for i in 0..2
    enf delta(s[i]) = 0 for i in 3..16

ev movup3(main: [s[16]]):
    enf s[0]' = s[3]
    enf s[i + 1]' = s[i] for i in 0..3
    enf delta(s[i]) = 0 for i in 4..16

ev movdn3(main: [s[16]]):
    enf s[3]' = s[0]
    enf s[i]' = s[i + 1] for i in 0..3
    enf delta(s[i]) = 0 for i in 4..16

ev advpopw(main: [s[16]]):
    enf delta(s[i]) = 0 for i in 4..16

ev expacc(main: [s[16]], aux: [h0]):
    enf is_binary([s[0]'])
    enf s[1]' = s[1]^2
    enf h0 = (s[1] - 1) * s[0]' + 1
    enf s[2]' = s[2] * h0
    enf s[3]' = s[3] * 2 + s[0]'
    enf delta(s[i]) = 0 for i in 4..16

ev movup4(main: [s[16]]):
    enf s[0]' = s[4]
    enf s[i + 1]' = s[i] for i in 0..4
    enf delta(s[i]) = 0 for i in 5..16

ev movdn4(main: [s[16]]):
    enf s[4]' = s[0] = 0
    enf s[i]' = s[i + 1] for i in 0..4
    enf delta(s[i]) = 0 for i in 5..16

ev movup5(main: [s[16]]):
    enf s[0]' = s[5]
    enf s[i + 1]' = s[i] for i in 0..5
    enf delta(s[i]) = 0 for i in 6..16

ev movdn5(main: [s[16]]):
    enf s[5]' = s[0]
    enf s[i]' = s[i + 1] for i in 0..5
    enf delta(s[i]) = 0 for i in 6..16

ev movup6(main: [s[16]]):
    enf s[0]' = s[6]
    enf s[i + 1]' = s[i] for i in 0..6
    enf delta(s[i]) = 0 for i in 7..16

ev movdn6(main: [s[16]]):
    enf s[6]' = s[0]
    enf s[i]' = s[i + 1] for i in 0..6
    enf delta(s[i]) = 0 for i in 7..16

ev movup7(main: [s[16]]):
    enf s[0]' = s[7] = 0
    enf s[i + 1]' = s[i] for i in 0..7
    enf delta(s[i]) = 0 for i in 8..16

ev movdn7(main: [s[16]]):
    enf s[7]' = s[0]
    enf s[i]' = s[i + 1] for i in 0..7
    enf delta(s[i]) = 0 for i in 8..16

ev swapw(main: [s[16]]):
    enf s[i]' = s[i + 4] for i in 0..4
    enf s[i + 4]' = s[i] for i in 0..4
    enf delta(s[i]) = 0 for i in 8..16

ev ext2mul(main: [s[16]]):
    enf s[0]' = s[0]
    enf s[1]' = s[1]
    enf s[2]' = (s[0] + s[1]) * (s[2] + s[3]) - s[0] * s[2]
    enf s[3]' = s[1] * s[3] - 2 * s[0] * s[2]
    enf delta(s[i]) = 0 for i in 4..16

ev movup8(main: [s[16]]):
    enf s[0]' = s[8]
    enf s[i + 1]' = s[i] for i in 0..8
    enf delta(s[i]) = 0 for i in 9..16

ev movdn8(main: [s[16]]):
    enf s[8]' = s[0]
    enf s[i]' = s[i + 1] for i in 0..8
    enf delta(s[i]) = 0 for i in 9..16

ev swapw2(main: [s[16]]):
    enf s[i]' = s[i + 8] for i in 0..4
    enf s[i + 8]' = s[i] for i in 0..4
    enf delta(s[i]) = 0 for i in 4..8
    enf delta(s[i]) = 0 for i in 12..16

# Should we enforce that elements in position grater than 15 do not change? 
ev swapw3(main: [s[16]]):
    enf s[i]' = s[i + 12] for i in 0..4
    enf s[i + 12]' = s[i] for i in 0..4
    enf delta(s[i]) = 0 for i in 4..12

# Should we enforce that elements in position grater than 15 do not change? 
ev swapdw(main: [s[16]]):
    enf s[i]' = s[i + 8] for i in 0..8
    enf s[i + 8]' = s[i] for i in 0..8


# Left stack shift operationds

ev assert(main: [s[16]]):
    enf s[0] = 1
    enf s[i]' = s[i + 1] for i in 0..15

ev eq(main: [s[16]], aux: [h0]):
    enf s[0]' * (s[0] - s[1]) = 0
    enf s[0]' = 1 - (s[0] - s[1]) * h0
    enf s[i]' = s[i + 1] for i in 1..15

ev add(main: [s[16]]):
    enf s[0]' = s[0] + s[1]
    enf s[i]' = s[i + 1] for i in 1..15

ev mul(main: [s[16]]):
    enf s[0]' = s[0] * s[1]
    enf s[i]' = s[i + 1] for i in 1..15

ev and(main: [s[16]]):
    enf is_binary([s[i]]) = 0 for i in 0..2
    enf s[0]' = s[0] * s[1]
    enf s[i]' = s[i + 1] for i in 1..15

ev or(main: [s[16]]):
    enf is_binary([s[i]]) = 0 for i in 0..2
    enf s[0]' = s[1] + s[0] - s[1] * s[0]
    enf s[i]' = s[i + 1] for i in 1..15

ev u32and(main: [s[16]], aux: [b_chip]):
    let op_u32and = 2
    enf b_chip' * (alpha[0] + alpha[1] * op_u32and + alpha[2] * s[0] + alpha[3] * s[1] + alpha[4] * s[0]') = b_chip
    enf s[i]' = s[i + 1] for i in 1..15

ev u32xor(main: [s[16]], aux: [b_chip]):
    let op_u32xor = 6
    enf b_chip' * (alpha[0] + alpha[1] * op_u32xor + alpha[2] * s[0] + alpha[3] * s[1] + alpha[4] * s[0]') = b_chip
    enf s[i]' = s[i + 1] for i in 1..15

# TODO: add constraints
ev frie2f4(main: [s[16]]):


ev drop(main: [s[16]]):
    enf s[i]' = s[i + 1] for i in 0..15

ev cswap(main: [s[16]]):
    enf is_binary([s[0]]) = 0
    enf s[0]' = s[0] * s[2] + (1 - s[0]) * s[1]
    enf s[1]' = s[0] * s[1] + (1 - s[0]) * s[2]
    enf s[i]' = s[i + 1] for i in 2..15

ev cswapw(main: [s[16]]):
    enf is_binary([s[0]]) = 0
    enf s[i]' = s[0] * s[i + 5] + (1 - s[0]) * s[i + 1] for i in 0..4
    enf s[i + 4]' = s[0] * s[i + 1] + (1 - s[0]) * s[i + 5] for i in 0..4
    enf s[i]' = s[i + 1] for i in 8..15

ev mloadw(main: [s[16]], aux: [clk, b_chip]):
    let v = sum([alpha[i + 5] * s[3 - i]' for i in 0..4])
    let op_mem_read = 12
    let u_mem = alpha[0] + alpha[1] * op_mem_read + alpha[3] * s[0] + alpha[4] * clk + v
    enf b_chip' * u_mem = b_chip
    enf s[i]' = s[i + 1] for i in 4..15

ev mstore(main: [s[16]], aux: [helper[3], clk, b_chip]):
    let v = alpha[5] * s[0]' + sum([alpha[i + 5] * helper[3 - i]' for i in 1..4])
    let op_mem_write = 4
    let u_mem = alpha[0] + alpha[1] * op_mem_write + alpha[3] * s[0] + alpha[4] * clk + v
    enf b_chip' * u_mem = b_chip
    enf s[i]' = s[i + 1] for i in 0..15

ev mstorew(main: [s[16]], aux: [clk, b_chip]):
    let v = sum([alpha[i + 5] * s[3 - i]']) for i in 0..4
    let op_mem_write = 4
    let u_mem = alpha[0] + alpha[1] * op_mem_write + alpha[3] * s[0] + alpha[4] * clk + v
    enf b_chip' * u_mem = b_chip
    enf s[i]' = s[i + 1] for i in 0..15

ev fmpupdate(main: [s[16]], aux: [fmp]):
    enf fmp' = fmp + s[0]
    enf s[i]' = s[i + 1] for i in 0..15


# Right stack shift operations

ev pad(main: [s[16]]):
    enf s[0]' = 0
    enf s[i + 1]' = s[i] for i in 0..15

ev dup(main: [s[16]]):
    enf s[0]' = s[0]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup1(main: [s[16]]):
    enf s[0]' = s[1]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup2(main: [s[16]]):
    enf s[0]' = s[2]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup3(main: [s[16]]):
    enf s[0]' = s[3]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup4(main: [s[16]]):
    enf s[0]' = s[4]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup5(main: [s[16]]):
    enf s[0]' = s[5]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup6(main: [s[16]]):
    enf s[0]' = s[6]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup7(main: [s[16]]):
    enf s[0]' = s[7]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup9(main: [s[16]]):
    enf s[0]' = s[9]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup11(main: [s[16]]):
    enf s[0]' = s[11]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup13(main: [s[16]]):
    enf s[0]' = s[13]
    enf s[i + 1]' = s[i] for i in 0..15

ev dup15(main: [s[16]]):
    enf s[0]' = s[15]
    enf s[i + 1]' = s[i] for i in 0..15

ev advpop(main: [s[16]]):
    enf s[i + 1]' = s[i] for i in 0..15

ev sdepth(main: [s[16], bookkeeping[2]]):
    enf s[0]' = bookkeeping[0]
    enf s[i + 1]' = s[i] for i in 0..15

ev clk(main: [s[16]], aux: [clk]):
    enf s[0]' = clk
    enf s[i + 1]' = s[i] for i in 0..15
