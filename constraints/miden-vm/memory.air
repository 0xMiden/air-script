mod MemoryAir

### Helper functions/evaluators ###################################################################

# Enforces that columns must be zero.
ev equal_zero(&main: [4]):
    enf v = 0 for v in &main

# Enforces that values in the columns in the current row must be equal to the values in the next 
# row.
ev equal_seq_lines(&main: [4]):
    enf v' = v for v in &main

### Memory Chiplet Air Constraints ################################################################

# Enforces the constraints on the memory chiplet, given the columns of the memory execution trace.
ev memory_chiplet(main: [s[2], ctx, addr, clk, v[4], d[2], t]):
    let delta_c = ctx' - ctx
    let delta_a = addr' - addr
    let delta_i = clk' - clk - 1

    # n0 = 1 when context changes and 0 otherwise.
    let n0 = delta_c * t'
    # if context remains the same, n1 = 1 when address changes and 0 otherwise.
    let n1 = delta_a * t'

    # Enforce that n0 must be binary.
    enf n0^2 = n0
    # Enforce that when context changes, n0 = 1 (or when n0 = 0, context remains the same).
    enf delta_c = 0 when !n0
    # Enforce that n1 must be binary. An additional condition ensures that the check of n1 
    # occurs only if the context does not change (n0 = 0).
    enf n1^2 = n1 when !n0
    # Enforce that if context remains the same, n1 = 1 when address changes and 0 otherwise.
    enf delta_a = 0 when !n0 & !n1

    # Enforce that values in the selectior columns must be binary.
    # s[0] is set to 0 for write operations and to 1 for read operations.
    enf col = col^2 for col in s

    # Enforce that s[1]' = 1 when the operation is a read and `ctx` and `addr` columns are both 
    # unchanged.
    enf s[1]' = 1 when !n0 & !n1 & s[0]'
    # Enforce that when either the context changed, the address changed, or the operation is a 
    # write, then s[1]' = 0
    enf s[1]' = 0 when n0 | n1 | !s[0]'

    let d_next_aggr = 2^16 * d[1]' + d[0]'

    # Enforce that values of context (`ctx`), address (`addr`), and clock cycle (`clk`) grow 
    # monotonically
    match enf:
        d_next_aggr = delta_c when n0
        d_next_aggr = delta_a when !n0 & n1
        d_next_aggr = delta_i when !n0 & !n1

    # TODO: perform range checks for values in columns d[0] and d[1]

    # Enforce that values at a given memory address are always initialized to 0.
    enf equal_zero([v]) when s[0] & !s[1]

    # Enforce that for the same context/address combination, the v columns of the current row are
    # equal to the corresponding v columns of the next row
    enf equal_seq_lines([v]) when s[1]

    # TODO: add constraint for chiplet bus