mod HashChipletAir

### Constants and periodic columns ################################################################

periodic_columns:
    cycle_row_0: [1, 0, 0, 0, 0, 0, 0, 0]
    cycle_row_6: [0, 0, 0, 0, 0, 0, 1, 0]
    cycle_row_7: [0, 0, 0, 0, 0, 0, 0, 1]


### Helper functions ##############################################################################

# Set to 1 when selector flags are (1,0,0) on rows which are multiples of 8. This flag indicates 
# that we are initiating computation of a single permutation, a 2-to-1 hash, or a linear hash of 
# many elements.
fn get_f_bp(s: vector[3]) -> scalar:
    return cycle_row_0 & s[0] & !s[1] & !s[2]


# Set to 1 when selector flags are (1,0,1) on rows which are multiples of 8. This is flag of the 
# instruction that initiates Merkle path verification computation.
fn get_f_mp(s: vector[3]) -> scalar:
    return cycle_row_0 & s[0] & !s[1] & s[2]


# Set to 1 when selector flags are (1,1,0) on rows which are multiples of 8. This is flag of the 
# instruction that initiates Merkle path verification for the "old" node value during Merkle root 
# update computation.
fn get_f_mv(s: vector[3]) -> scalar:
    return cycle_row_0 & s[0] & s[1] & !s[2]


# Set to 1 when selector flags are (1,1,1) on rows which are multiples of 8. This is flag of the 
# instruction that initiates Merkle path verification for the "new" node value during Merkle root 
# update computation.
fn get_f_mu(s: vector[3]) -> scalar:
    return cycle_row_0 & s[0] & s[1] & s[2]

# Set to 1 when selector flags are (0,0,0) on rows which are 1 less than a multiple of 8. This flag
# indicates that the result of the currently running computation is returned.
fn get_f_hout(s: vector[3]) -> scalar:
    return cycle_row_7 & !s[0] & !s[1] & !s[2]


# Set to 1 when selector flags are (0,0,1) on rows which are 1 less than a multiple of 8. This flag
# indicates that the entire hasher state is returned.
fn get_f_sout(s: vector[3]) -> scalar:
    return cycle_row_7 & !s[0] & !s[1] & s[2]


# Set to 1 when selector flags are (1,0,0) on rows which are 1 less than a multiple of 8. This 
# is flag of the instruction that absorbs a new set of elements into the hasher state when 
# computing a linear hash of many elements.
fn get_f_abp(s: vector[3]) -> scalar:
    return cycle_row_7 & s[0] & !s[1] & !s[2]


# Set to 1 when selector flags are (1,0,1) on rows which are 1 less than a multiple of 8. This 
# is flag of the instruction that absorbs the next Merkle path node into the hasher state 
# during Merkle path verification computation.
fn get_f_mpa(s: vector[3]) -> scalar:
    return cycle_row_7 & s[0] & !s[1] & s[2]


# Set to 1 when selector flags are (1,1,0) on rows which are 1 less than a multiple of 8. This 
# is flag of the instruction that absorbs the next Merkle path node into the hasher state 
# during Merkle path verification for the "old" node value during Merkle root update 
# computation.
fn get_f_mva(s: vector[3]) -> scalar:
    return cycle_row_7 & s[0] & s[1] & !s[2]


# Set to 1 when selector flags are (1,1,1) on rows which are 1 less than a multiple of 8. This 
# is flag of the instruction that absorbs the next Merkle path node into the hasher state 
# during Merkle path verification for the "new" node value during Merkle root update 
# computation.
fn get_f_mua(s: vector[3]) -> scalar:
    return cycle_row_7 & s[0] & s[1] & s[2]


# Flag f_out is set to 1 when either f_hout = 1 or f_sout = 1 in the current row.
fn get_f_out(s: vector[3]) -> scalar:
    return cycle_row_7 & !s[0] & !s[1]

# Flag f_out is set to 1 when either f_hout = 1 or f_sout = 1 in the next row. Notice that this 
# function should be used only with next row values (s'),
fn get_f_out_next(s: vector[3]) -> scalar:
    return cycle_row_6 & !s[0] & !s[1]


### Helper evaluators #############################################################################

# Enforces that column must be binary.
#
# Constraint degree: 2
ev is_binary([a]):
    enf a^2 = a


# Enforces that value in column is copied over to the next row.
#
# Constraint degree: 1
ev is_unchanged([column]):
    ev column' = column


# Enforce selector columns constraints.
#
# Max constraint degree: 7
ev selector_columns([s[3]]):
    let f_out = get_f_out(s)
    let f_out_next = get_f_out_next(s')
    let f_abp = get_f_abp(s)
    let f_mpa = get_f_mpa(s)
    let f_mva = get_f_mva(s)
    let f_mua = get_f_mua(s)

    # Flag that is true when the performed operation is one of the represented by flags f_abp, 
    # f_mpa, f_mva or f_mua
    let f_comp = f_abp + f_mpa + f_mva + f_mua

    # Enforce that selector columns are binary.
    # Constraint degree: 2
    enf is_binary([selector]) for selector in s

    # Enforce that unless f_out = 1 or f_out' = 1, the values in columns s[1] and s[2] are copied 
    # over to the nex row.
    # Constraints degree: 7
    enf is_unchanged([s[1]]) when !f_out & !f_out_next
    enf is_unchanged([s[2]]) when !f_out & !f_out_next

    # Enforce that if any of f_abp, f_mpa, f_mva, f_mua flags is set to 1, the next value of s[0] 
    # is 0.
    # Constraint degree: 5
    enf s[0]' * f_comp = 0

    # Enforce that no invalid combinations of flags are allowed.
    # Constraint degree: 3
    enf cycle_row_7 * !s[0] * s[1] = 0


# Enforce node index constraints.
#
# Max constraint degree: 6
ev node_index([s[3], i]):
    let f_out = get_f_out(s)
    let f_mp = get_f_mp(s)
    let f_mv = get_f_mv(s)
    let f_mu = get_f_mu(s)
    let f_mpa = get_f_mpa(s)
    let f_mva = get_f_mva(s)
    let f_mua = get_f_mua(s)

    # b is the value of the bit which is discarded during shift by one bit to the right.
    let b = i - 2 * i'

    # Flag that allows to enforce constraint that b is binary only when a new node is absorbed into
    # the hasher state (when the hash operation is one of Merkle path verification operations or 
    # next Merkle path node absorption operations)
    let f_an = f_mp + f_mv + f_mu + f_mpa + f_mva + f_mua

    # Enforce that b is binary only when a new node is absorbed into the hasher state.
    # Constraint degree: 6
    enf f_an * (b^2 - b) = 0

    # Enforce that when a computation is finished i = 0.
    # Constraint degree: 4
    enf f_out * i = 0

    # Enforce that the value in i is copied over to the next row unless we are absorbing a new row 
    # or the computation is finished.
    # Constraint degree: 5
    let absorbing_or_comp_finished = 1 - f_an - f_out
    enf is_unchanged([i]) when absorbing_or_comp_finished


# Enforce hasher state constraints
#
# Max constraint degree: 6
ev hasher_state([s[3], h[12], i]):
    let f_mp = get_f_mp(s)
    let f_mv = get_f_mv(s)
    let f_mu = get_f_mu(s)
    let f_abp = get_f_abp(s)

    # Flag that is true when the performed operation includes absorbing the next node during Merkle
    # path computation.
    let f_absorb_node = f_mp + f_mv + f_mu

    # b is the value of the bit which is discarded during shift by one bit to the right.
    let b = i - 2 * i'

    # Enforce that when absorbing the next set of elements into the state during linear hash 
    # computation (i.e. f_abp = 1) the first 4 elements (the capacity portion) are carried over to 
    # the next row.
    # Constraint degree: 5
    enf f_abp * (h[j]' - h[j]) = 0 for j in 0..4

    # Enforce that when absorbing the next node during Merkle path computation 
    # (i.e. f_mp + f_mv + f_mu = 1), the result of the previous hash (h[4], ..., h[7]) are copied 
    # over either to (h[4]', ..., h[7]') or to (h[8]', ..., h[11]') depending on the value of b.
    # Constraint degree: 6
    match enf:
        is_unchanged(h[j + 4]) for j in 0..4 when !b & f_absorb_node
        h[j + 8]' = h[j + 4] for j in 0..4 when b & f_absorb_node


# Enforce constraints for the hash chiplet bus.
#
# Constraint degree: 7
ev chiplet_bus([s[3], r, h[12], i], [p0]):
    # Compute falgs required for the chiplet bus constraint.
    let f_bp = get_f_bp(s)
    let f_sout = get_f_sout(s)
    let f_hout = get_f_hout(s)
    let f_out = get_f_out(s)
    let f_mp = get_f_mp(s)
    let f_mv = get_f_mv(s)
    let f_mu = get_f_mu(s)
    let f_abp = get_f_abp(s)

    let op_label = 2^3 * s[2] + 2^2 * s[1] + 2^1 * s[0] + 1
    let transition_label = op_label + 2^4 * cycle_row_7  + 2^5 * cycle_row_0

    # v_h is a common header.
    let v_h = $alpha[0] + $alpha[1] * transition_label + $alpha[2] * r + $alpha[3] * i

    # v_a, v_b and v_c are the first, second, and third words of the hasher state.
    let v_a = sum([$alpha[j + 4] * h[j] for j in 0..4])
    let v_b = sum([$alpha[j + 4] * h[j] for j in 4..8])
    let v_b_next = sum([$alpha[j + 4] * h[j]' for j in 4..8])
    let v_c = sum([$alpha[j + 4] * h[j] for j in 8..12])
    let v_c_next = sum([$alpha[j + 4] * h[j]' for j in 8..12])

    # v_d is the third word of the hasher state but computed using the same alphas values as used 
    # for the second word.
    let v_d = sum([$alpha[j] * h[j] for j in 8..12])
    
    # v_all represents the entire hasher state.
    let v_all = v_h + v_a + v_b + v_c

    # b is the value of the bit which is discarded during shift by one bit to the right.
    let b = i - 2 * i'

    # v_leaf represents the leaf of the path.
    let v_leaf = v_h + (1 - b) * v_b + b * v_d

    # v_abp represents delta between the last 8 elements of the hasher state during absorption a 
    # new set of elements into the state while computing a linear hash.
    let v_abp = v_h + v_b_next + v_c_next - (v_b + v_c)

    # v_res represents returning the hash result, taken from the second word of the hasher state.
    let v_res = v_h + v_b

    # Enforce constraints for updating column p0.
    # Constraint degree: 7
    p0' = p0 * ((f_bp + f_sout) * v_all + (f_mp + f_mv + f_mu) * v_leaf + f_abp * v_abp + 
                f_hout * v_res + 1 - (f_bp + f_mp + f_mv + f_mu + f_abp + f_out))


# Enforce constraints for the hash chiplet sibling table, which is used to keep track of sibling 
# nodes used during Merkle root update computations. For this computation, we need to enforce the 
# following rules:
# 1. When computing the old Merkle root, whenever a new sibling node is absorbed into the hasher 
#    state (i.e., f_mv + f_mva = 1), an entry for this sibling should be included into p1.
# 2. When computing the new Merkle root, whenever a new sibling node is absorbed into the hasher 
#    state (i.e., f_mu + f_mua = 1), the entry for this sibling should be removed from p1.
#
# Max constraint degree: 7
ev hash_sibling_table([s[3], r, h[12], i], [p1]):
    # Compute falgs required for the sibling table constraints.
    let f_mv = get_f_mv(s)
    let f_mu = get_f_mu(s)
    let f_mva = get_f_mva(s)
    let f_mua = get_f_mua(s)
    let f_bp = get_f_bp(s)
    let f_mp = get_f_mp(s)

    # b is the value of the bit which is discarded during shift by one bit to the right.
    let b = i - 2 * i'

    let v_b = sum([$alpha[j + 4] * h[j] for j in 4..8])
    let v_c = sum([$alpha[j + 4] * h[j] for j in 8..12])

    # v_sibling represents an entry in the sibling table.
    let v_sibling = $alpha[0] + $alpha[3] * i + b * v_b + (1 - b) * v_c

    # Enforce constraint for updating p1.
    # Constraint degree: 7
    enf p1' * ((f_mv + f_mva) * v_sibling + 1 - (f_mv + f_mva)) = 
        p1 * ((f_mu + f_mua) * v_sibling + 1 - (f_mu + f_mua))

    # Enforce that computation of the old Merkle root is immediately followed by the computation of 
    # the new Merkle root.
    # Constraint degree: 5
    enf (f_bp + f_mp + f_mv) * (1 - p1) = 0


### Hash Chiplet Air Constraints ##################################################################

# Enforces the constraints on the hash chiplet, given the columns of the hash execution trace.
#
# Max constraint degree: 7
ev hash_chiplet([s[3], r, h[12], i]):
    ## Row address constraint ##
    # TODO: Apply row address constraints:
    # 1. Boundary constraint `enf r.first = 1`
    # 2. Transition constraint. It requires chiplets module's selector flag s0.

    ## Selector columns constraints ##
    enf selector_columns([s])

    ## Node index constraints ##
    enf node_index([s, i])

    ## Hasher state constraints ##
    # TODO: apply RPO constraints to the hasher state
    enf hasher_state([s, h, i])

    ## Multiset check constraints ##
    enf chiplet_bus([s, r, h, i], [p0])
    enf hash_sibling_table([s, r, h, i], [p1])
