proc.cache_z_exp
    padw mem_loadw.4294903304 drop drop
    # => [z_1, z_0, ...]
    # Find number exponentiations required to get for a period of length 8
    mem_load.4294903307 neg add.3
    # => [count, z_1, z_0, ...] where count = -log2(trace_len) + 3
    # Exponentiate z
    dup.0 neq.0
    while.true
        movdn.2 dup.1 dup.1 ext2mul
        # => [(z_1, z_0)^n, i, ...]
        movup.2 add.1 dup.0 neq.0
        # => [b, i+1, (z_1, z_0)^n, ...]
    end # END while
    push.0 mem_storew.500000100 # z^8
    # => [0, 0, (z_1, z_0)^n, ...] where n = trace_len-8
    drop drop
    # Find number of exponentiations to bring from length 8 to 4
    push.18446744069414584320
    # => [count, (z_1, z_0)^3, ...] where count = 2 - 3
    # Exponentiate z
    dup.0 neq.0
    while.true
        movdn.2 dup.1 dup.1 ext2mul
        # => [(z_1, z_0)^n, i, ...]
        movup.2 add.1 dup.0 neq.0
        # => [b, i+1, (z_1, z_0)^n, ...]
    end # END while
    push.0 mem_storew.500000101 # z^4
    # => [0, 0, (z_1, z_0)^n, ...] where n = trace_len-4
    drop drop
    # Exponentiate z 4 times, until trace_len
    push.18446744069414584319
    # => [count, (z_1, z_0)^n, ...] where count=-2 , n=trace_len-2
    dup.0 neq.0
    while.true
        movdn.2 dup.1 dup.1 ext2mul
        # => [(z_1, z_0)^n, i, ...]
        movup.2 add.1 dup.0 neq.0
        # => [b, i+1, (z_1, z_0)^n, ...]
    end # END while
    push.0 mem_storew.500000102 # z^trace_len
    # => [0, 0, (z_1, z_0)^trace_len, ...]
    dropw # Clean stack
end # END PROC cache_z_exp

proc.cache_periodic_polys
    # periodic column 0
    padw mem_loadw.500000101 drop drop
    # => [z_exp_1, z_exp_0, ...]
    push.13835058052060938241 push.0
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.13835058052060938241 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.13835058052060938241 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.13835058052060938241 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # Clean z_exp from the stack
    movup.3 movup.3 drop drop
    # => [a_1, a_0, ...]
    # Save the evaluation of the periodic polynomial at point z**exp, and clean stack
    push.0 push.0 mem_storew.500000000 dropw # periodic column 1
    padw mem_loadw.500000100 drop drop
    # => [z_exp_1, z_exp_0, ...]
    push.2305843008676823041 push.0
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.18446744069412487169 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.18446708885042495489 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.18446743931975630881 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.16140901060737761281 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.2097152 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.35184372088832 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.137438953440 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # Clean z_exp from the stack
    movup.3 movup.3 drop drop
    # => [a_1, a_0, ...]
    # Save the evaluation of the periodic polynomial at point z**exp, and clean stack
    push.0 push.0 mem_storew.500000001 dropw
end # END PROC cache_periodic_polys

proc.compute_evaluate_integrity_constraints
    # integrity constraint 0 for main
    padw mem_loadw.500000001 drop drop padw mem_loadw.4294900001 movdn.3 movdn.3 drop drop padw mem_loadw.4294900002 movdn.3 movdn.3 drop drop ext2add ext2mul push.0 push.0 ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900200 movdn.3 movdn.3 drop drop ext2mul
    # integrity constraint 1 for main
    padw mem_loadw.500000000 drop drop padw mem_loadw.4294900000 drop drop padw mem_loadw.4294900000 movdn.3 movdn.3 drop drop ext2sub ext2mul push.0 push.0 ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900200 drop drop ext2mul
end # END PROC compute_evaluate_integrity_constraints

proc.compute_evaluate_boundary_constraints
    # boundary constraint 0 for main
    padw mem_loadw.4294900000 movdn.3 movdn.3 drop drop push.0 push.0 ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900201 movdn.3 movdn.3 drop drop ext2mul
end # END PROC compute_evaluate_boundary_constraints

proc.evaluate_integrity_constraints
    exec.cache_periodic_polys
    exec.compute_evaluate_integrity_constraints
    # Accumulate the numerator of the constraint polynomial
    ext2add ext2add
end # END PROC evaluate_integrity_constraints

proc.evaluate_boundary_constraints
    exec.compute_evaluate_boundary_constraints
    # Accumulate the numerator of the constraint polynomial
    ext2add
end # END PROC evaluate_boundary_constraints

