proc.get_exemptions_points
    mem_load.4294903306
    # => [trace_len, ...]
    dup.0 push.131064 u32checked_and neq.0 # Included(3)..Included(16)
    if.true
        dup.0 push.2040 u32checked_and neq.0 # Included(3)..Included(10)
        if.true
            dup.0 push.120 u32checked_and neq.0 # Included(3)..Included(6)
            if.true
                dup.0 push.24 u32checked_and neq.0 # Included(3)..Included(4)
                if.true
                    push.8 u32checked_and neq.0 # Test if trace length is a power of 2^3
                    push.18442240469788262401 push.18446742969902956801 dup.2 cdrop push.18446742969902956801 push.18446462594437873665 movup.3 cdrop
                else
                    push.32 u32checked_and neq.0 # Test if trace length is a power of 2^5
                    push.16140901060737761281 push.18158513693329981441 dup.2 cdrop push.18158513693329981441 push.18442240469788262401 movup.3 cdrop
                end # END else
            else
                dup.0 push.384 u32checked_and neq.0 # Included(7)..Included(8)
                if.true
                    push.128 u32checked_and neq.0 # Test if trace length is a power of 2^7
                    push.9171943329124577373 push.274873712576 dup.2 cdrop push.274873712576 push.16140901060737761281 movup.3 cdrop
                else
                    push.512 u32checked_and neq.0 # Test if trace length is a power of 2^9
                    push.4088309022520035137 push.5464760906092500108 dup.2 cdrop push.5464760906092500108 push.9171943329124577373 movup.3 cdrop
                end # END else
            end # END else
        else
            dup.0 push.30720 u32checked_and neq.0 # Included(11)..Included(14)
            if.true
                dup.0 push.6144 u32checked_and neq.0 # Included(11)..Included(12)
                if.true
                    push.2048 u32checked_and neq.0 # Test if trace length is a power of 2^11
                    push.386651765402340522 push.6141391951880571024 dup.2 cdrop push.6141391951880571024 push.4088309022520035137 movup.3 cdrop
                else
                    push.8192 u32checked_and neq.0 # Test if trace length is a power of 2^13
                    push.2841727033376697931 push.11575992183625933494 dup.2 cdrop push.11575992183625933494 push.386651765402340522 movup.3 cdrop
                end # END else
            else
                push.32768 u32checked_and neq.0 # Test if trace length is a power of 2^15
                push.9071788333329385449 push.8892493137794983311 dup.2 cdrop push.8892493137794983311 push.2841727033376697931 movup.3 cdrop
            end # END else
        end # END else
    else
        dup.0 push.33423360 u32checked_and neq.0 # Included(17)..Included(24)
        if.true
            dup.0 push.1966080 u32checked_and neq.0 # Included(17)..Included(20)
            if.true
                dup.0 push.393216 u32checked_and neq.0 # Included(17)..Included(18)
                if.true
                    push.131072 u32checked_and neq.0 # Test if trace length is a power of 2^17
                    push.14996013474702747840 push.15139302138664925958 dup.2 cdrop push.15139302138664925958 push.9071788333329385449 movup.3 cdrop
                else
                    push.524288 u32checked_and neq.0 # Test if trace length is a power of 2^19
                    push.6451340039662992847 push.5708508531096855759 dup.2 cdrop push.5708508531096855759 push.14996013474702747840 movup.3 cdrop
                end # END else
            else
                dup.0 push.6291456 u32checked_and neq.0 # Included(21)..Included(22)
                if.true
                    push.2097152 u32checked_and neq.0 # Test if trace length is a power of 2^21
                    push.10420286214021487819 push.5102364342718059185 dup.2 cdrop push.5102364342718059185 push.6451340039662992847 movup.3 cdrop
                else
                    push.8388608 u32checked_and neq.0 # Test if trace length is a power of 2^23
                    push.17538441494603169704 push.13945510089405579673 dup.2 cdrop push.13945510089405579673 push.10420286214021487819 movup.3 cdrop
                end # END else
            end # END else
        else
            dup.0 push.503316480 u32checked_and neq.0 # Included(25)..Included(28)
            if.true
                dup.0 push.100663296 u32checked_and neq.0 # Included(25)..Included(26)
                if.true
                    push.33554432 u32checked_and neq.0 # Test if trace length is a power of 2^25
                    push.8974194941257008806 push.16784649996768716373 dup.2 cdrop push.16784649996768716373 push.17538441494603169704 movup.3 cdrop
                else
                    push.134217728 u32checked_and neq.0 # Test if trace length is a power of 2^27
                    push.5506647088734794298 push.16194875529212099076 dup.2 cdrop push.16194875529212099076 push.8974194941257008806 movup.3 cdrop
                end # END else
            else
                dup.0 push.1610612736 u32checked_and neq.0 # Included(29)..Included(30)
                if.true
                    push.536870912 u32checked_and neq.0 # Test if trace length is a power of 2^29
                    push.16558868196663692994 push.7731871677141058814 dup.2 cdrop push.7731871677141058814 push.5506647088734794298 movup.3 cdrop
                else
                    drop push.9896756522253134970 push.16558868196663692994
                end # END else
            end # END else
        end # END else
    end # END else
end # END PROC get_exemptions_points

proc.cache_z_exp
    padw mem_loadw.4294903304 drop drop
    # => [z_1, z_0, ...]
    # Number of exponentiations for a period of length 8
    mem_load.4294903307 neg add.3
    # => [count, z_1, z_0, ...]
    # Exponentiate z
    dup.0 neq.0
    while.true
        movdn.2 dup.1 dup.1 ext2mul
        # => [z_1^2, z_0^2, i, ...]
        movup.2 add.1 dup.0 neq.0
        # => [b, i+1, z_1^2, z_0^2, ...]
    end # END while
    push.0 mem_storew.500000100 # z^exp for period 8
    # => [0, 0, z_1^2, z_0^2, ...]
    drop drop
    # Exponentiate z 8 times, until trace_len
    push.18446744069414584313 dup.0 neq.0
    while.true
        movdn.2 dup.1 dup.1 ext2mul
        # => [z_1^2, z_0^2, i, ...]
        movup.2 add.1 dup.0 neq.0
        # => [b, i+1, z_1^2, z_0^2, ...]
    end # END while
    push.0 mem_storew.500000101 # z^exp for trace_len
    # => [0, 0, z_1^2, z_0^2, ...]
    drop drop
    # => [z_1^2, z_0^2, num_of_cycles', -log2(trace_len), ...]
    # Clean stack
    dropw
end # END PROC cache_z_exp

proc.cache_periodic_polys
    # periodic column 0
    padw mem_loadw.500000100 drop drop
    # => [z_exp_1, z_exp_0, ...]
    push.2305843008676823041 push.0
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.18446744069412487169 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.18446708885042495489 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.18446743931975630881 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.16140901060737761281 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.2097152 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.35184372088832 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # duplicate z_exp
    dup.3 dup.3
    # => [z_exp_1, z_exp_0, a_1, a_0, z_exp_1, z_exp_0, ...]
    ext2mul push.137438953440 push.0 ext2add
    # => [a_1, a_0, z_exp_1, z_exp_0, ...]
    # Clean z_exp from the stack
    movup.3 movup.3 drop drop
    # => [a_1, a_0, ...]
    # Save the evaluation of the periodic polynomial at point z**exp, and clean stack
    push.0 push.0 mem_storew.500000000 dropw
end # END PROC cache_periodic_polys

proc.compute_integrity_constraint_divisor
    padw mem_loadw.500000101 drop drop
    # Comments below use zt = `z^trace_len`
    # => [zt_1, zt_0, ...]
    push.1 push.0 ext2sub
    # => [zt_1-1, zt_0-1, ...]
    padw mem_loadw.4294903304 drop drop
    # => [z_1, z_0, zt_1-1, zt_0-1, ...]
    exec.get_exemptions_points
    # => [g^{trace_len-2}, g^{trace_len-1}, z_1, z_0, zt_1-1, zt_0-1, ...]
    dup.3 dup.3 movup.3 push.0 ext2sub
    # => [e_1, e_0, g^{trace_len-1}, z_1, z_0, zt_1-1, zt_0-1, ...]
    movup.4 movup.4 movup.4 push.0 ext2sub
    # => [e_3, e_2, e_1, e_0, zt_1-1, zt_0-1, ...]
    ext2mul
    # => [denominator_1, denominator_0, zt_1-1, zt_0-1, ...]
    ext2div
    # => [divisor_1, divisor_0, ...]
end # END PROC compute_integrity_constraint_divisor

proc.compute_evaluate_integrity_constraints
    # integrity constraint 0 for main
    padw mem_loadw.4294900000 movdn.3 movdn.3 drop drop
    # push the accumulator to the stack
    push.1 movdn.2 push.0 movdn.2
    # => [b1, b0, r1, r0, ...]
    # square 1 times
    dup.1 dup.1 ext2mul
    # multiply
    dup.1 dup.1 movdn.5 movdn.5
    # => [b1, b0, r1, r0, b1, b0, ...] (4 cycles)
    ext2mul movdn.3 movdn.3
    # => [b1, b0, r1', r0', ...] (5 cycles)
    # clean stack
    drop drop
    # => [r1, r0, ...] (2 cycles)
    padw mem_loadw.4294900000 movdn.3 movdn.3 drop drop ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900200 movdn.3 movdn.3 drop drop ext2mul
    # integrity constraint 1 for main
    padw mem_loadw.500000000 drop drop padw mem_loadw.4294900000 drop drop padw mem_loadw.4294900000 movdn.3 movdn.3 drop drop ext2sub ext2mul push.0 push.0 ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900200 drop drop ext2mul
    # integrity constraint 2 for main
    push.1 push.0 padw mem_loadw.4294900000 movdn.3 movdn.3 drop drop ext2sub padw mem_loadw.4294900003 movdn.3 movdn.3 drop drop padw mem_loadw.4294900001 movdn.3 movdn.3 drop drop ext2sub padw mem_loadw.4294900002 movdn.3 movdn.3 drop drop ext2sub ext2mul push.2 push.0 push.3 push.0 ext2mul padw mem_loadw.4294900000 movdn.3 movdn.3 drop drop ext2sub ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900201 movdn.3 movdn.3 drop drop ext2mul
    # integrity constraint 3 for main
    padw mem_loadw.4294900000 movdn.3 movdn.3 drop drop padw mem_loadw.4294900003 movdn.3 movdn.3 drop drop padw mem_loadw.4294900001 movdn.3 movdn.3 drop drop padw mem_loadw.4294900002 movdn.3 movdn.3 drop drop ext2mul ext2sub ext2mul padw mem_loadw.4294900000 drop drop push.3 push.0 ext2sub push.4 push.0 push.2 push.0 ext2sub ext2sub ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900201 drop drop ext2mul
    # integrity constraint 0 for aux
    padw mem_loadw.4294900073 drop drop padw mem_loadw.4294900073 movdn.3 movdn.3 drop drop padw mem_loadw.4294900003 movdn.3 movdn.3 drop drop padw mem_loadw.4294900150 movdn.3 movdn.3 drop drop ext2add ext2mul ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900202 movdn.3 movdn.3 drop drop ext2mul
end # END PROC compute_evaluate_integrity_constraints

proc.compute_evaluate_boundary_constraints
    # boundary constraint 0 for main
    padw mem_loadw.4294900001 movdn.3 movdn.3 drop drop push.0 push.0 ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900202 drop drop ext2mul
    # boundary constraint 1 for main
    padw mem_loadw.4294900001 movdn.3 movdn.3 drop drop push.1 push.0 ext2sub
    # Multiply by the composition coefficient
    padw mem_loadw.4294900203 movdn.3 movdn.3 drop drop ext2mul
end # END PROC compute_evaluate_boundary_constraints

proc.evaluate_integrity_constraints
    exec.cache_periodic_polys
    exec.compute_evaluate_integrity_constraints
    # Numerator of the transition constraint polynomial
    ext2add ext2add ext2add ext2add ext2add
    # Divisor of the transition constraint polynomial
    exec.compute_integrity_constraint_divisor
    ext2div # divide the numerator by the divisor
end # END PROC evaluate_integrity_constraints

proc.evaluate_boundary_constraints
    exec.compute_evaluate_boundary_constraints
    # Accumulate the numerator of the constraint polynomial
    ext2add ext2add
end # END PROC evaluate_boundary_constraints

