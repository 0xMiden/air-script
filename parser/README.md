# Parser

This crate contains the parser for AirScript.

The purpose of the parser is to parse the constraints written in the human-friendly AirScript language into an Abstract Syntax Tree.

## Generating the Abstract Syntax Tree (AST)

The parser uses [Logos](https://github.com/maciejhirsz/logos/) to generate a custom lexer, which is then fed into the parser generated by [LALRPOP](https://github.com/lalrpop/lalrpop/).

To create an AST from a given AirScript module, pass your source to the public `parse` function, which will return the AST or an `Error` of type `ScanError` or `ParseError`.

The `parse` function will first tokenize the source using the lexer, then map the resulting tokens to new tokens accepted by the parser, which are of type `(usize, Token, usize)`. Each invalid token will be stored as `ScanError`. Finally, if no `ScanError` occurred, `parse` feeds the tokens to the parser to generate a Result with the corresponding AST (or `ParseError`).

Example usage:

```Rust
// parse the source string to a Result containing the AST or an Error
let ast = parse(source.as_str());
```

## AST

The AirScript AST (`Source`) contains a vector of `SourceSection`, each of which contains the result of parsing a section in an AirScript module.

The `SourceSection` types are:

- `AirDef`, which holds the name of the AIR.
- `TraceCols`, which contains the parsed trace column information for the main and auxiliary execution traces. Each column is represented by its identifier.
- `PublicInputs`, which is a vector of all of the public inputs defined in the module. Each public input is represented by its identifier and a fixed size.
- `PeriodicColumns`, which is a vector of all of the periodic columns defined in the module. Each periodic column is represented by its identifier and a vector containing the pattern of its repeated (periodic) values.
- `BoundaryConstraints`, which contains a vector of `BoundaryConstraint` expressions, each represented as an expression tree.
- `IntegrityConstraints`, which contains a vector of `IntegrityConstraint` expressions, each represented as an expression tree.
