use crate::{
    ast::{
        boundary_constraints::{Boundary, BoundaryConstraint, BoundaryStmt, BoundaryExpr,
        BoundaryVariable, BoundaryVariableType}, 
        transition_constraints::{TransitionConstraint, TransitionExpr, TransitionStmt,
        TransitionVariable, TransitionVariableType},
        constants::{Constant, ConstantType},
        Identifier, Source, SourceSection, TraceCols, PublicInput, PeriodicColumn, VectorAccess,
        MatrixAccess
    }, error::{Error, ParseError::{InvalidInt, InvalidTraceCols, MissingMainTraceCols,
    InvalidConst, MissingBoundaryConstraint, MissingTransitionConstraint}}, lexer::Token
};
use std::str::FromStr;
use lalrpop_util::ParseError;

grammar;

// AST NODE
// ================================================================================================

pub Source: Source = {
    SourceSection* => Source(<>)
}

SourceSection: SourceSection = {
    AirDef => SourceSection::AirDef(<>),
    Constants => SourceSection::Constants(<>),
    TraceCols => SourceSection::TraceCols(<>),
    PublicInputs => SourceSection::PublicInputs(<>),
    PeriodicColumns => SourceSection::PeriodicColumns(<>),
    BoundaryConstraints => SourceSection::BoundaryConstraints(<>),
    TransitionConstraints => SourceSection::TransitionConstraints(<>),
}

// AIR DEF
// ================================================================================================

AirDef: Identifier = {
    "def" <f: Identifier> => f
}

// TRACE COLUMNS
// ================================================================================================

TraceCols: TraceCols = {
    "trace_columns" ":" <main_cols: MainCols?> <aux_cols: AuxCols?> =>? match (main_cols, aux_cols)
    {
        (Some(main_cols), Some(aux_cols)) => Ok(TraceCols { main_cols, aux_cols }),
        (Some(main_cols), None) => Ok(TraceCols { main_cols, aux_cols: vec![] }),
        (None, Some(_aux_cols)) => Err(ParseError::User {
            error: Error::ParseError(
                MissingMainTraceCols("Declaration of main trace columns is required".to_string())
            )
        }),
        (None, None) => Err(ParseError::User {
            error: Error::ParseError(InvalidTraceCols("Trace Columns cannot be empty".to_string()))
        })
    } 
}

MainCols: Vec<Identifier> = {
    "main" ":" "[" <main_cols: CommaElems<Identifier>> "]" => main_cols,
}

AuxCols: Vec<Identifier> = {
    "aux" ":" "[" <aux_cols: CommaElems<Identifier>> "]" => aux_cols,
}

// CONSTANTS
// ================================================================================================

// The constants section is optional but cannot be empty. If the section is declared, then at least
// one constant is required.
Constants: Vec<Constant> = {
    "constants" ":" <constants: Constant+> => constants
}

Constant: Constant = {
    <name: ConstName> ":" <scalar_value: Num_u64> => 
        Constant::new(name, ConstantType::Scalar(scalar_value)),
    <name: ConstName> ":" "[" <vector_value: CommaElems<Num_u64>> "]" =>
        Constant::new(name, ConstantType::Vector(vector_value)),
    <name: ConstName> ":" "[" <matrix_value: CommaElems<Vector<Num_u64>>> "]" =>
        Constant::new(name, ConstantType::Matrix(matrix_value)),
}

ConstName: Identifier = {
    <name: Identifier> =>? if name.0.chars().all(|v| v.is_uppercase()) {
        Ok(Identifier(name.to_string()))
    } else {
        Err(ParseError::User {
            error: Error::ParseError(InvalidConst(
                format!("The constant name should be uppercase: {}", <>).to_string()
            ))
        })
    }
}

// PUBLIC INPUTS
// ================================================================================================

// At least one public input is required.
PublicInputs: Vec<PublicInput> = {
    "public_inputs" ":" <pub_inputs: PublicInput+> => pub_inputs
}

PublicInput: PublicInput = {
    <name: Identifier> ":" <size: Size> => PublicInput::new(name, size),
}

// PERIODIC COLUMNS
// ================================================================================================

// Periodic columns are not required, and there is no limit to the number that can be provided.
PeriodicColumns: Vec<PeriodicColumn> = {
    "periodic_columns" ":" <periodic_columns: PeriodicColumn*> => periodic_columns
}

PeriodicColumn: PeriodicColumn = {
    <name: Identifier> ":" "[" <values: CommaElems<Num_u64>> "]" =>
        PeriodicColumn::new(name, values),
}

// BOUNDARY CONSTRAINTS
// ================================================================================================

BoundaryConstraints: Vec<BoundaryStmt> = {
    "boundary_constraints" ":" <boundary_stmts: BoundaryStmt+> =>? {
        // check if at least one boundary constraint is defined
        let boundary_constraints_exist = boundary_stmts.iter().any(|stmt| match stmt {
            BoundaryStmt::Constraint(_) => true,
            _ => false,
        });
        if !boundary_constraints_exist {
            return Err(ParseError::User {
                error: Error::ParseError(
                    MissingBoundaryConstraint(
                        "Declaration of at least one boundary constraint is required".to_string()
                    )
                )
            });
        }
        Ok(boundary_stmts)
    }
}

BoundaryStmt: BoundaryStmt = {
    "enf" <column: Identifier> "." <boundary: Boundary> "=" <value: BoundaryExpr> =>
        BoundaryStmt::Constraint(BoundaryConstraint::new(column, boundary, value)),
    "let" <name: Identifier> "=" <boundary_variable_type: BoundaryVariableType> =>
        BoundaryStmt::Variable(BoundaryVariable::new(name, boundary_variable_type)),
}

BoundaryVariableType: BoundaryVariableType = {
    <scalar_value: BoundaryExpr> =>
        BoundaryVariableType::Scalar(scalar_value),
    "[" <vector_value: CommaElems<BoundaryExpr>> "]" =>
        BoundaryVariableType::Vector(vector_value),
    "[" <matrix_value: CommaElems<Vector<BoundaryExpr>>> "]" =>
        BoundaryVariableType::Matrix(matrix_value),
}

Boundary: Boundary = {
    "first" => Boundary::First,
    "last" => Boundary::Last
}

// --- BOUNDARY CONSTRAINT EXPRESSIONS WITH PRECEDENCE (LOWEST TO HIGHEST) ----------------------

BoundaryExpr: BoundaryExpr = {
    <lexpr: BoundaryExpr> "+" <rexpr: BoundaryFactor> =>
        BoundaryExpr::Add(Box::new(lexpr), Box::new(rexpr)),
    <lexpr: BoundaryExpr> "-" <rexpr: BoundaryFactor> =>
        BoundaryExpr::Sub(Box::new(lexpr), Box::new(rexpr)),
    BoundaryFactor
}

BoundaryFactor: BoundaryExpr = {
    <lexpr: BoundaryFactor> "*" <rexpr: BoundaryAtom> =>
        BoundaryExpr::Mul(Box::new(lexpr), Box::new(rexpr)),
    BoundaryAtom
}

BoundaryAtom: BoundaryExpr = {
    "(" <BoundaryExpr> ")",
    <lexpr: BoundaryAtom> "^" <num: Num_u64> => BoundaryExpr::Exp(Box::new(lexpr), num),
    "$rand" <idx: Index> => BoundaryExpr::Rand(idx),
    <n: Num_u64> => BoundaryExpr::Const(n),
    <ident: Identifier> => BoundaryExpr::Elem(ident),
    <vector_access: VectorAccess> => BoundaryExpr::VectorAccess(vector_access),
    <matrix_access: MatrixAccess> => BoundaryExpr::MatrixAccess(matrix_access)
}

// TRANSITION CONSTRAINTS
// ================================================================================================

TransitionConstraints: Vec<TransitionStmt> = {
    "transition_constraints" ":" <transition_stmts: TransitionStmt+> =>? {
        // check if at least one transition constraint is defined
        let transition_constraints_exist = transition_stmts.iter().any(|stmt| match stmt {
            TransitionStmt::Constraint(_) => true,
            _ => false,
        });
        if !transition_constraints_exist {
            return Err(ParseError::User {
                error: Error::ParseError(
                    MissingTransitionConstraint(
                        "Declaration of at least one transition constraint is required".to_string()
                    )
                )
            });
        }
        Ok(transition_stmts)
    }
}

TransitionStmt: TransitionStmt = {
    "enf" <lhs: TransitionExpr> "=" <rhs: TransitionExpr> =>
        TransitionStmt::Constraint(TransitionConstraint::new(lhs, rhs)),
    "let" <name: Identifier> "=" <transition_variable_type: TransitionVariableType> =>
        TransitionStmt::Variable(TransitionVariable::new(name, transition_variable_type)),
}

TransitionVariableType: TransitionVariableType = {
    <scalar_value: TransitionExpr> =>
        TransitionVariableType::Scalar(scalar_value),
    "[" <vector_value: CommaElems<TransitionExpr>> "]" =>
        TransitionVariableType::Vector(vector_value),
    "[" <matrix_value: CommaElems<Vector<TransitionExpr>>> "]" =>
        TransitionVariableType::Matrix(matrix_value),
}

// --- TRANSITION CONSTRAINT EXPRESSIONS WITH PRECEDENCE (LOWEST TO HIGHEST) ----------------------

TransitionExpr: TransitionExpr = {
    <lexpr: TransitionExpr> "+" <rexpr: TransitionFactor> =>
        TransitionExpr::Add(Box::new(lexpr), Box::new(rexpr)),
    <lexpr: TransitionExpr> "-" <rexpr: TransitionFactor> =>
        TransitionExpr::Sub(Box::new(lexpr), Box::new(rexpr)),
    TransitionFactor
}

TransitionFactor: TransitionExpr = {
    <lexpr: TransitionFactor> "*" <rexpr: TransitionAtom> =>
        TransitionExpr::Mul(Box::new(lexpr), Box::new(rexpr)),
    TransitionAtom
}

TransitionAtom: TransitionExpr = {
    "(" <TransitionExpr> ")",
    <lexpr: TransitionAtom> "^" <num: Num_u64> => TransitionExpr::Exp(Box::new(lexpr), num),
    "$rand" <idx: Index> => TransitionExpr::Rand(idx),
    <n: Num_u64> => TransitionExpr::Const(n),
    <ident: Identifier> => TransitionExpr::Elem(ident),
    <vector_access: VectorAccess> => TransitionExpr::VectorAccess(vector_access),
    <matrix_access: MatrixAccess> => TransitionExpr::MatrixAccess(matrix_access),
    <ident: Identifier> "'" => TransitionExpr::Next(ident)
}

// ATOMS
// ================================================================================================

CommaElems<T>: Vec<T> = {
    <e:T> <v:("," <T>)*> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
}

Vector<T>: Vec<T> = {
    "[" <e:T> <v:("," <T>)*> "]" => {
        let mut v = v;
        v.insert(0, e);
        v
    }
}

Size: u64 = {
    "[" <size: Num_u64> "]" => size
}

Index: usize = {
    "[" <idx: Num_u64> "]" => idx as usize
}

VectorAccess: VectorAccess = {
    <ident: Identifier> <idx: Index> => VectorAccess::new(ident, idx)
}

MatrixAccess: MatrixAccess = {
    <ident: Identifier> <row: Index> <col: Index> =>
        MatrixAccess::new(ident, row, col)
}

Identifier: Identifier = {
    <n:identifier> => Identifier(n.to_string())
}

Num_u64: u64 = {
    r"[0-9]+" =>? u64::from_str(&<>)
        .map_err(|_| ParseError::User {
            error: Error::ParseError(InvalidInt(format!("Int too big : {}", <>).to_string()))
        })
}

// LEXER
// ================================================================================================

extern {
    type Error = Error;
    type Location = usize;

    enum Token {
        identifier => Token::Ident(<String>),
        r"[0-9]+" => Token::Num(<String>),
        "def" => Token::Def,
        "let" => Token::Let,
        "constants" => Token::Constants,
        "trace_columns" => Token::TraceColumnns,
        "main" => Token::Main,
        "aux" => Token::Aux,
        "public_inputs" => Token::PublicInputs,
        "periodic_columns" => Token::PeriodicColumns,
        "boundary_constraints" => Token::BoundaryConstraints,
        "first" => Token::First,
        "last" => Token::Last,
        "transition_constraints" => Token::TransitionConstraints,
        "$rand" => Token::Rand,
        "enf" => Token::Enf,
        "'" => Token::Next,
        "=" => Token::Equal,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "^" => Token::Exp,
        ":" => Token::Colon,
        "," => Token::Comma,
        "[" => Token::Lsqb,
        "]" => Token::Rsqb,
        "(" => Token::Lparen,
        ")" => Token::Rparen,
        "." => Token::Dot,
    }
}
